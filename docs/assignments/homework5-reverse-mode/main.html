<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.319">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>CS 152: Neural Networks - Homework 5: Reverse-mode Automatic Differentiation</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">CS 152: Neural Networks</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html" rel="" target="">
 <span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../calendar/calendar.html" rel="" target="">
 <span class="menu-text">Calendar</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://drive.google.com/drive/folders/1JFhwmcFBTHiRbfhQ0VRDj9xIPxFpHuWj?usp=drive_link" rel="" target="">
 <span class="menu-text">Homeworks</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../assignments/final-project/outline.html" rel="" target="">
 <span class="menu-text">Project</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://github.com/orgs/CS152/" rel="" target="">
 <span class="menu-text">Github</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="https://www.gradescope.com/courses/710173" rel="" target="">
 <span class="menu-text">Gradescope</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#collaborators" id="toc-collaborators" class="nav-link active" data-scroll-target="#collaborators">Collaborators</a></li>
  <li><a href="#course-feedback" id="toc-course-feedback" class="nav-link" data-scroll-target="#course-feedback">Course feedback</a></li>
  <li><a href="#overview" id="toc-overview" class="nav-link" data-scroll-target="#overview">Overview</a></li>
  <li><a href="#part-1-reverse-mode-automatic-differentiation" id="toc-part-1-reverse-mode-automatic-differentiation" class="nav-link" data-scroll-target="#part-1-reverse-mode-automatic-differentiation">Part 1: Reverse-mode automatic differentiation</a></li>
  <li><a href="#part-2-training-a-neural-network" id="toc-part-2-training-a-neural-network" class="nav-link" data-scroll-target="#part-2-training-a-neural-network">Part 2: Training a neural network</a></li>
  <li><a href="#part-3-vectorizing-reverse-mode-automatic-differentiation" id="toc-part-3-vectorizing-reverse-mode-automatic-differentiation" class="nav-link" data-scroll-target="#part-3-vectorizing-reverse-mode-automatic-differentiation">Part 3: Vectorizing Reverse-mode automatic differentiation</a>
  <ul class="collapse">
  <li><a href="#matrix-multiplication" id="toc-matrix-multiplication" class="nav-link" data-scroll-target="#matrix-multiplication">Matrix multiplication</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><strong>Homework 5:</strong> Reverse-mode Automatic Differentiation</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<section id="collaborators" class="level3">
<h3 class="anchored" data-anchor-id="collaborators">Collaborators</h3>
<p>Please list anyone you discussed or collaborated on this assignment with below.</p>
<p>LIST COLLABORATORS HERE</p>
</section>
<section id="course-feedback" class="level3">
<h3 class="anchored" data-anchor-id="course-feedback">Course feedback</h3>
<p>Please submit this week’s course survey here: https://forms.gle/PJjGy8wrhhQnAhbb6</p>
</section>
<section id="overview" class="level2">
<h2 class="anchored" data-anchor-id="overview">Overview</h2>
<p>In this homework we will build a tiny reverse-mode automatic differentiation library!</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Uncomment and run if using Colab!</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">#import urllib.request</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">#remote_url = 'https://gist.githubusercontent.com/gabehope/d3e6b10338a1ba78f53204fc7502eda5/raw/52631870b1475b5ef8d9701f1c676fa97bf7b300/hw5_support.py'</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">#with urllib.request.urlopen(remote_url) as remote, open('hw5_support.py', 'w') as local:</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">#  [local.write(str(line, encoding='utf-8')) for line in remote]</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Run me first!</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> hw5_support <span class="im">import</span> <span class="op">*</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="python-features" class="level4">
<h4 class="anchored" data-anchor-id="python-features">Python features</h4>
<p>This homework makes use of a few fancy features in Python that are worth knowing about if you are unfamiliar. - <a href="https://book.pythontips.com/en/latest/args_and_kwargs.html">Variable length arguments</a> (e.g.&nbsp;<code>*args</code>) - <a href="https://book.pythontips.com/en/latest/comprehensions.html#list-comprehensions">List comprehensions</a> (e.g.&nbsp;<code>[a**2 for a in range(5)]</code>) - <a href="https://rszalski.github.io/magicmethods/">Magic methods</a> (e.g.&nbsp;<code>__add__</code>)</p>
</section>
</section>
<section id="part-1-reverse-mode-automatic-differentiation" class="level2">
<h2 class="anchored" data-anchor-id="part-1-reverse-mode-automatic-differentiation">Part 1: Reverse-mode automatic differentiation</h2>
<p>We’ll start by developing an automatic differentiation class that uses <em>reverse-mode automatic differentiation</em>, as this is what will be most useful for neural networks.</p>
<p>Recall that for reverse-mode AD to work, everytime we perform an operation on one or more numbers we need to store the result of that operation as well as the <em>parent values</em> (the inputs to the operation). We also need to be able to compute the derivative of that operation. Since for every operation we need to store several pieces of data and several functions, it makes sense to define a <em>class</em> to represent the result of an operation.</p>
<p>For example, if we want to make a class that represents the operation <code>c=a+b</code> our class needs several properties: - <code>value</code>: The value of the operation (<code>c</code>) - <code>parents</code>: The parent operations (<code>a</code> and <code>b</code>) - <code>grad</code>: The derivative of the final loss with respect to <code>c</code> (<span class="math inline">\(\frac{dL}{dc}\)</span>) - <code>func</code>: A function that computes the operation (<code>a+b</code>) - <code>grads</code>: A function that computes the derivatives of the operation (<span class="math inline">\(\frac{dc}{da}\)</span> and <span class="math inline">\(\frac{dc}{db}\)</span>)</p>
<p>For this homework, we’ve provided the outline of such a class, called <code>AutogradValue</code>. This will be the base class for all of our possible operations and represents declaring a variable with a value (<code>a = 5</code>). This is useful because it lets us define values that we might want to find derivatives with respect to.</p>
<p>Let’s see how this will work in practice. If we want to take derivatives we will first define the inputs using <code>AutogradValue</code>.</p>
<pre class="{python}"><code>a = AutogradValue(5)
b = AutogradValue(2)</code></pre>
<p>Then we can perform whatever operations we want on these inputs:</p>
<pre class="{python}"><code>c = a + b
L = log(c)</code></pre>
<p>Each of these operations will produce a new <code>AutogradValue</code> object representing the result of that operation.</p>
<p>Finally we can run the backward pass by running a method <code>backward()</code> (that we will write) on the outout <code>L</code>. This will compute the gradients of <code>L</code> with respect to each input that we defined (<span class="math inline">\(\frac{dL}{da}\)</span> and <span class="math inline">\(\frac{dL}{db}\)</span>). Rather than returning these derivatives, the <code>backward()</code> method will <em>update</em> the <code>grad</code> property of <code>a</code> and <code>b</code>, making it easy to access the correct derivative.</p>
<pre class="{python}"><code>L.backward()
dL_da = a.grad</code></pre>
<p>We’ll also be able to compute operations with non-AutogradValue numbers, but obviously won’t be able to compute derivaitives with respect to these values.</p>
<pre class="{python}"><code>s = 4
L = s * a
dL_da = a.grad # Will work because a is an AutogradValue
dL_ds = s.grad # Will give an error because s is not an AutogradValue</code></pre>
<p>Now that we’ve seen what our final produce will look like, let’s define our <code>AutogradValue</code> class.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> AutogradValue:</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Base class for automatic differentiation operations. Represents variable delcaration.</span></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Subclasses will overwrite func and grads to define new operations.</span></span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="co">    Properties:</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a><span class="co">        parents (list): A list of the inputs to the operation, may be AutogradValue or float</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a><span class="co">        args    (list): A list of raw values of each input (as floats)</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a><span class="co">        grad    (float): The derivative of the final loss with respect to this value (dL/da)</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a><span class="co">        value   (float): The value of the result of this operation</span></span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, <span class="op">*</span>args):</span>
<span id="cb6-14"><a href="#cb6-14" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.parents <span class="op">=</span> <span class="bu">list</span>(args)</span>
<span id="cb6-15"><a href="#cb6-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.args <span class="op">=</span> [arg.value <span class="cf">if</span> <span class="bu">isinstance</span>(arg, AutogradValue) <span class="cf">else</span> arg <span class="cf">for</span> arg <span class="kw">in</span> <span class="va">self</span>.parents]</span>
<span id="cb6-16"><a href="#cb6-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.grad <span class="op">=</span> <span class="fl">0.</span></span>
<span id="cb6-17"><a href="#cb6-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.value <span class="op">=</span> <span class="va">self</span>.forward_pass()</span>
<span id="cb6-18"><a href="#cb6-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-19"><a href="#cb6-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> func(<span class="va">self</span>, <span class="bu">input</span>):</span>
<span id="cb6-20"><a href="#cb6-20" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb6-21"><a href="#cb6-21" aria-hidden="true" tabindex="-1"></a><span class="co">        Compute the value of the operation given the inputs.</span></span>
<span id="cb6-22"><a href="#cb6-22" aria-hidden="true" tabindex="-1"></a><span class="co">        For declaring a variable, this is just the identity function (return the input).</span></span>
<span id="cb6-23"><a href="#cb6-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-24"><a href="#cb6-24" aria-hidden="true" tabindex="-1"></a><span class="co">        Args:</span></span>
<span id="cb6-25"><a href="#cb6-25" aria-hidden="true" tabindex="-1"></a><span class="co">            input (float): The input to the operation</span></span>
<span id="cb6-26"><a href="#cb6-26" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns:</span></span>
<span id="cb6-27"><a href="#cb6-27" aria-hidden="true" tabindex="-1"></a><span class="co">            value (float): The result of the operation</span></span>
<span id="cb6-28"><a href="#cb6-28" aria-hidden="true" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb6-29"><a href="#cb6-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">input</span></span>
<span id="cb6-30"><a href="#cb6-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-31"><a href="#cb6-31" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> grads(<span class="va">self</span>, <span class="op">*</span>args):</span>
<span id="cb6-32"><a href="#cb6-32" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb6-33"><a href="#cb6-33" aria-hidden="true" tabindex="-1"></a><span class="co">        Compute the derivative of the operation with respect to each input.</span></span>
<span id="cb6-34"><a href="#cb6-34" aria-hidden="true" tabindex="-1"></a><span class="co">        In the base case the derivative of the identity function is just 1. (da/da = 1).</span></span>
<span id="cb6-35"><a href="#cb6-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-36"><a href="#cb6-36" aria-hidden="true" tabindex="-1"></a><span class="co">        Args:</span></span>
<span id="cb6-37"><a href="#cb6-37" aria-hidden="true" tabindex="-1"></a><span class="co">            input (float): The input to the operation</span></span>
<span id="cb6-38"><a href="#cb6-38" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns:</span></span>
<span id="cb6-39"><a href="#cb6-39" aria-hidden="true" tabindex="-1"></a><span class="co">            grads (tuple): The derivative of the operation with respect to each input</span></span>
<span id="cb6-40"><a href="#cb6-40" aria-hidden="true" tabindex="-1"></a><span class="co">                            Here there is only a single input, so we return a length-1 tuple.</span></span>
<span id="cb6-41"><a href="#cb6-41" aria-hidden="true" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb6-42"><a href="#cb6-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (<span class="dv">1</span>,)</span>
<span id="cb6-43"><a href="#cb6-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-44"><a href="#cb6-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> forward_pass(<span class="va">self</span>):</span>
<span id="cb6-45"><a href="#cb6-45" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Calls func to compute the value of this operation</span></span>
<span id="cb6-46"><a href="#cb6-46" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.func(<span class="op">*</span><span class="va">self</span>.args)</span>
<span id="cb6-47"><a href="#cb6-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-48"><a href="#cb6-48" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>):</span>
<span id="cb6-49"><a href="#cb6-49" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Python magic function for string representation.</span></span>
<span id="cb6-50"><a href="#cb6-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="bu">str</span>(<span class="va">self</span>.value)</span>
<span id="cb6-51"><a href="#cb6-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-52"><a href="#cb6-52" aria-hidden="true" tabindex="-1"></a></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now that we’ve defined the framework for an operation that can be used in automatic differentiation, we need to define some actual useful operations by subclassing <code>AutogradValue</code>. These subclasses will look the same as the ones we wrote for our forward-mode automatic differentiation in the last homework.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> _add(AutogradValue):</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> func(<span class="va">self</span>, a, b):</span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a <span class="op">+</span> b</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> grads(<span class="va">self</span>, a, b):</span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fl">1.</span>, <span class="fl">1.</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> _sub(AutogradValue):</span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> func(<span class="va">self</span>, a, b):</span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a <span class="op">-</span> b</span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> grads(<span class="va">self</span>, a, b):</span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="fl">1.</span>, <span class="op">-</span><span class="fl">1.</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> _neg(AutogradValue):</span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> func(<span class="va">self</span>, a):</span>
<span id="cb7-17"><a href="#cb7-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span>a</span>
<span id="cb7-18"><a href="#cb7-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-19"><a href="#cb7-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> grads(<span class="va">self</span>, a):</span>
<span id="cb7-20"><a href="#cb7-20" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (<span class="op">-</span><span class="fl">1.</span>,)</span>
<span id="cb7-21"><a href="#cb7-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-22"><a href="#cb7-22" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> _mul(AutogradValue):</span>
<span id="cb7-23"><a href="#cb7-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> func(<span class="va">self</span>, a, b):</span>
<span id="cb7-24"><a href="#cb7-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a <span class="op">*</span> b</span>
<span id="cb7-25"><a href="#cb7-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-26"><a href="#cb7-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> grads(<span class="va">self</span>, a, b):</span>
<span id="cb7-27"><a href="#cb7-27" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> b, a</span>
<span id="cb7-28"><a href="#cb7-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-29"><a href="#cb7-29" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> _div(AutogradValue):</span>
<span id="cb7-30"><a href="#cb7-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> func(<span class="va">self</span>, a, b):</span>
<span id="cb7-31"><a href="#cb7-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a <span class="op">/</span> b</span>
<span id="cb7-32"><a href="#cb7-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-33"><a href="#cb7-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> grads(<span class="va">self</span>, a, b):</span>
<span id="cb7-34"><a href="#cb7-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span> <span class="op">/</span> b, <span class="op">-</span>a <span class="op">/</span> (b <span class="op">*</span> b)</span>
<span id="cb7-35"><a href="#cb7-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-36"><a href="#cb7-36" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> _exp(AutogradValue):</span>
<span id="cb7-37"><a href="#cb7-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> func(<span class="va">self</span>, a):</span>
<span id="cb7-38"><a href="#cb7-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> math.exp(a)</span>
<span id="cb7-39"><a href="#cb7-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-40"><a href="#cb7-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> grads(<span class="va">self</span>, a):</span>
<span id="cb7-41"><a href="#cb7-41" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (math.exp(a),)</span>
<span id="cb7-42"><a href="#cb7-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-43"><a href="#cb7-43" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> _log(AutogradValue):</span>
<span id="cb7-44"><a href="#cb7-44" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> func(<span class="va">self</span>, a):</span>
<span id="cb7-45"><a href="#cb7-45" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> math.log(a)</span>
<span id="cb7-46"><a href="#cb7-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-47"><a href="#cb7-47" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> grads(<span class="va">self</span>, a):</span>
<span id="cb7-48"><a href="#cb7-48" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (<span class="dv">1</span> <span class="op">/</span> a,)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Below, we’ll define our basic functions and operators in terms of the operator classes we just wrote.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Note: Remember that above we defined a class for each type of operation</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="co"># so in this code we are overriding the basic operators for AutogradValue</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co"># such that they construct a new object of the class corresponding to the</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="co"># given operation and return it.</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co"># (You don't need to everything that's happening here to do the HW)</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a>AutogradValue.exp <span class="op">=</span> <span class="kw">lambda</span> a: _exp(a)</span>
<span id="cb8-7"><a href="#cb8-7" aria-hidden="true" tabindex="-1"></a>AutogradValue.log <span class="op">=</span> <span class="kw">lambda</span> a: _log(a)</span>
<span id="cb8-8"><a href="#cb8-8" aria-hidden="true" tabindex="-1"></a>AutogradValue.<span class="fu">__add__</span> <span class="op">=</span> <span class="kw">lambda</span> a, b: _add(a, b)</span>
<span id="cb8-9"><a href="#cb8-9" aria-hidden="true" tabindex="-1"></a>AutogradValue.<span class="fu">__radd__</span> <span class="op">=</span> <span class="kw">lambda</span> a, b: _add(b, a)</span>
<span id="cb8-10"><a href="#cb8-10" aria-hidden="true" tabindex="-1"></a>AutogradValue.<span class="fu">__sub__</span> <span class="op">=</span> <span class="kw">lambda</span> a, b: _sub(a, b)</span>
<span id="cb8-11"><a href="#cb8-11" aria-hidden="true" tabindex="-1"></a>AutogradValue.<span class="fu">__rsub__</span> <span class="op">=</span> <span class="kw">lambda</span> a, b: _sub(b, a)</span>
<span id="cb8-12"><a href="#cb8-12" aria-hidden="true" tabindex="-1"></a>AutogradValue.<span class="fu">__neg__</span> <span class="op">=</span> <span class="kw">lambda</span> a: _neg(a)</span>
<span id="cb8-13"><a href="#cb8-13" aria-hidden="true" tabindex="-1"></a>AutogradValue.<span class="fu">__mul__</span> <span class="op">=</span> <span class="kw">lambda</span> a, b: _mul(a, b)</span>
<span id="cb8-14"><a href="#cb8-14" aria-hidden="true" tabindex="-1"></a>AutogradValue.<span class="fu">__rmul__</span> <span class="op">=</span> <span class="kw">lambda</span> a, b: _mul(b, a)</span>
<span id="cb8-15"><a href="#cb8-15" aria-hidden="true" tabindex="-1"></a>AutogradValue.<span class="fu">__truediv__</span> <span class="op">=</span> <span class="kw">lambda</span> a, b: _div(a, b)</span>
<span id="cb8-16"><a href="#cb8-16" aria-hidden="true" tabindex="-1"></a>AutogradValue.<span class="fu">__rtruediv__</span> <span class="op">=</span> <span class="kw">lambda</span> a, b: _div(b, a)</span>
<span id="cb8-17"><a href="#cb8-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-18"><a href="#cb8-18" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> exp(a):</span>
<span id="cb8-19"><a href="#cb8-19" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a.exp() <span class="cf">if</span> <span class="bu">isinstance</span>(a, AutogradValue) <span class="cf">else</span> np.exp(a)</span>
<span id="cb8-20"><a href="#cb8-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> log(a):</span>
<span id="cb8-21"><a href="#cb8-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a.log() <span class="cf">if</span> <span class="bu">isinstance</span>(a, AutogradValue) <span class="cf">else</span> np.log(a)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We should now be able to use our <code>AutogradValue</code> objects as if they are numbers!</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> AutogradValue(<span class="dv">5</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> AutogradValue(<span class="dv">2</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>((a <span class="op">+</span> <span class="dv">5</span>) <span class="op">*</span> b)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(log(b))</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>test_operators(AutogradValue)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s confirm that we do keep the entire compuational graph for operations defined in this way.</p>
<section id="q1" class="level4">
<h4 class="anchored" data-anchor-id="q1">Q1</h4>
<p>Write a function <code>graph_print</code> that takes a single argument. If the argument is an <code>AutogradValue</code> (or one of its subclasses), print its <code>value</code> property and then call <code>graph_print</code> on each of its parents. If the argument is not an <code>AutogradValue</code>, just print it. The format of printing is not important.</p>
<p><em><strong>Hint:</strong> You can use the built-in Python function <code>isinstance</code> to determine if something is an <code>AutogradValue</code> or one of its subclasses. e.g.&nbsp;<code>isinstance(a, AutogradValue)</code></em></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> graph_print(a):</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">## YOUR CODE HERE</span></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> AutogradValue(<span class="fl">5.</span>)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> AutogradValue(<span class="fl">2.</span>)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> log((a <span class="op">+</span> <span class="dv">5</span>) <span class="op">*</span> b)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>graph_print(c)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>The function should print (it’s ok if the numbers or order aren’t exact):</p>
<pre><code>2.995732273553991
20.0
10.0
5.0
5.0
5
2.0
2.0</code></pre>
<p>Now in order to do automatic differentiation, we need to define how to do the backward pass. We’ll start with the backward_step for a single operation.</p>
</section>
<section id="q2" class="level4">
<h4 class="anchored" data-anchor-id="q2">Q2</h4>
<p>Fill in the method <code>backward_pass</code> which computes a single step of the reverse pass through the computational graph (assume <code>self</code> is an <code>AutogradValue</code> instance). If <code>backward_pass</code> is called on a value <code>c</code>, the method should: - Assume that <code>self.grad</code> contains the derivaive of the final loss with respect to <code>c</code> (<span class="math inline">\(\frac{dL}{dc}\)</span>). - Check if each parent of <code>c</code> is an <code>AutogradValue</code>. If it is, update that parent’s <code>grad</code> property to account for <code>c</code> (e.g.&nbsp;for parent <code>a</code>, update the value of <span class="math inline">\(\frac{dL}{da}\)</span>)</p>
<p><strong>For example:</strong> if <code>c</code> represents the result of an addition so <code>c = a + b</code>, calling <code>backward_pass</code> on <code>c</code> will update the <code>grad</code> property of both <code>a</code> and <code>b</code>. (<code>a.grad</code> represents <span class="math inline">\(\frac{dL}{da}\)</span> and is initialized to <code>0</code>).</p>
<p><em><strong>Hint:</strong> <code>grads</code> will be one of the methods we wrote in the last homework (and shown above). Recall that if <code>c</code> has parents <code>a</code> and <code>b</code> then <code>grads</code> method will give <span class="math inline">\(\frac{dc}{da}\)</span> and <span class="math inline">\(\frac{dc}{db}\)</span>.</em></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backward_pass(<span class="va">self</span>):</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">## YOUR CODE HERE</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>    local_grads <span class="op">=</span> <span class="va">self</span>.grads(<span class="op">*</span><span class="va">self</span>.args)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a>AutogradValue.backward_pass <span class="op">=</span> backward_pass</span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Test our implementation</span></span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>test_backward_pass(AutogradValue)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Finally we need to define the backward method itself. We will call this on the loss value to find the derivatives of the loss with respect to each input. This means working our way backward through the sequence of operations. Remember that if <code>c=a+b</code>, then if <code>c.grad</code> is <span class="math inline">\(\frac{dL}{dc}\)</span>, calling <code>backward_pass</code> on <code>c</code> will update <span class="math inline">\(\frac{dL}{da}\)</span> (<code>a.grad</code>) and <span class="math inline">\(\frac{dL}{db}\)</span> (<code>b.grad</code>).</p>
<p>The complication is that <code>c</code> may be used in multiple operations, so we can’t call <code>backward_pass</code> on <code>c</code> until we’ve called <code>backward_pass</code> on each child operation of <code>c</code> otherwise <code>c.grad</code> won’t have the correct value of <span class="math inline">\(\frac{dL}{dc}\)</span>, as in this example:</p>
<pre class="{python}"><code>c = a + b
g = c * 2
h = c + 4
L = g * h

L.backward_pass() # Updates dL/dg and dL/dh
h.backward_pass() # Updates dL/dc

##WRONG ORDER
c.backward_pass() # Incorrect because dL/dc hasn't accounted for dL/dg
g.backward_pass()

## CORRECT ORDER
g.backward_pass() # Updates dL/dc
c.backward_pass() # Updates dL/da and dL/db</code></pre>
</section>
<section id="q3" class="level4">
<h4 class="anchored" data-anchor-id="q3">Q3</h4>
<p>Fill in the <code>backward</code> method for <code>AutogradValue</code>. Your backward method should call <code>backward_pass</code> on each operation used to compute the loss (<code>self</code> is the loss value). Some important things to keep in mind: - <code>backward_pass</code> should only be called <strong>once</strong> on each operation - <code>backward_pass</code> must be called on <strong>every child</strong> of an operation before it can be called on the operation. - You should not try to call <code>backward_pass</code> on values that aren’t instances of <code>AutogradValue</code>, even though they might be stored in <code>operation.parents</code></p>
<p><em><strong>Hint:</strong> We discussed a simple approach to this problem in class! We won’t score efficiency in grading, but it still might be worth optimizing this function a bit.</em></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backward(<span class="va">self</span>):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># We call backward on the loss, so dL/dL = 1</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.grad <span class="op">=</span> <span class="fl">1.</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a>    <span class="co">## YOUR CODE HERE</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>AutogradValue.backward <span class="op">=</span> backward</span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Test our implementation</span></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>test_backward(AutogradValue)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now we can use our <code>AutogradValue</code> class to compute derivatives!</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> AutogradValue(<span class="dv">5</span>)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> AutogradValue(<span class="dv">2</span>)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> <span class="op">-</span>log(<span class="dv">5</span> <span class="op">*</span>b <span class="op">+</span> a)</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a>L.backward()</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(a.grad, b.grad)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>If we want to train a neural network using our automatic differentiation implementation, we’re going to want to be able to use numpy to do matrix operations. Fortunately, the our <code>AutogradValue</code> class is (mostly) compatible with numpy!</p>
<p>We can create arrays of <code>AutogradValue</code> and take derivatives as shown below:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> np.array([AutogradValue(<span class="dv">5</span>), AutogradValue(<span class="dv">2</span>)])</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> np.dot(a, a)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a>L.backward()</span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Gradient for a'</span>, a[<span class="dv">0</span>].grad, a[<span class="dv">1</span>].grad)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>It would be a bit tedious to define every AutogradValue array in this way, so let’s write some convinience functions to make doing automatic differentiation with numpy easier.</p>
</section>
<section id="q4" class="level4">
<h4 class="anchored" data-anchor-id="q4">Q4</h4>
<p>Complete the following two functions <code>wrap_array</code> and <code>unwrap_gradient</code>.</p>
<p><code>wrap_array</code> should take a numpy array of floats and return a new array where every element has been made into an <code>AutogradValue</code>.</p>
<p><code>unwrap_gradient</code> should take a numpy array of <code>AutogradValue</code> and return a new array of floats, where every element is the extracted <code>grad</code> property of the corresponding element from the original array.</p>
<p>Both of these functions should work on 2-D arrays (matrices) at a minimum (but more general solutions that support 1 and/or &gt;2 dimensional arrays are also possible).</p>
<p><em><strong>Hint:</strong> You can create an array from nested lists as <code>np.array([[1, 2], [3, 4]])</code>.</em></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> wrap_array(a):</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Wraps the elements of an array with AutogradValue</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a><span class="co">        a (array of float): The array to wrap</span></span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb17-8"><a href="#cb17-8" aria-hidden="true" tabindex="-1"></a><span class="co">        g (array of AutogradValue): An array g, such that g[i,j] = AutogradValue(a[i,j])</span></span>
<span id="cb17-9"><a href="#cb17-9" aria-hidden="true" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb17-10"><a href="#cb17-10" aria-hidden="true" tabindex="-1"></a>    <span class="co">## YOUR CODE HERE</span></span>
<span id="cb17-11"><a href="#cb17-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-12"><a href="#cb17-12" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> unwrap_gradient(a):</span>
<span id="cb17-13"><a href="#cb17-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb17-14"><a href="#cb17-14" aria-hidden="true" tabindex="-1"></a><span class="co">    Unwraps the gradient of an array with AutogradValues</span></span>
<span id="cb17-15"><a href="#cb17-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-16"><a href="#cb17-16" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb17-17"><a href="#cb17-17" aria-hidden="true" tabindex="-1"></a><span class="co">        a (array of AutogradValue): The array to unwrap</span></span>
<span id="cb17-18"><a href="#cb17-18" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb17-19"><a href="#cb17-19" aria-hidden="true" tabindex="-1"></a><span class="co">        g (array of float): An array g, such that g[i,j] = a[i,j].grad</span></span>
<span id="cb17-20"><a href="#cb17-20" aria-hidden="true" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb17-21"><a href="#cb17-21" aria-hidden="true" tabindex="-1"></a>    <span class="co">## YOUR CODE HERE</span></span>
<span id="cb17-22"><a href="#cb17-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-23"><a href="#cb17-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb17-24"><a href="#cb17-24" aria-hidden="true" tabindex="-1"></a>test_wrap_unwrap(wrap_array, unwrap_gradient, AutogradValue)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="part-2-training-a-neural-network" class="level2">
<h2 class="anchored" data-anchor-id="part-2-training-a-neural-network">Part 2: Training a neural network</h2>
<p>Now we’re ready to test out our <code>AutogradValue</code> implementation in the context it’s designed for: neural networks! Below is a (slightly modified) version of the neural network class we wrote for the last homework.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> pad(a):</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Pads an array with a column of 1s (for bias term)</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a.pad() <span class="cf">if</span> <span class="bu">isinstance</span>(a, AutogradValue) <span class="cf">else</span> np.pad(a, ((<span class="dv">0</span>, <span class="dv">0</span>), (<span class="dv">0</span>, <span class="dv">1</span>)), constant_values<span class="op">=</span><span class="fl">1.</span>, mode<span class="op">=</span><span class="st">'constant'</span>)</span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> matmul(a, b):</span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Multiplys two matrices</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> _matmul(a, b) <span class="cf">if</span> (<span class="bu">isinstance</span>(a, AutogradValue) <span class="kw">or</span> <span class="bu">isinstance</span>(b, AutogradValue)) <span class="cf">else</span> np.matmul(a, b)</span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sigmoid(x):</span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Computes the sigmoid function</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="fl">1.</span> <span class="op">/</span> (<span class="fl">1.</span> <span class="op">+</span> (<span class="op">-</span>x).exp()) <span class="cf">if</span> <span class="bu">isinstance</span>(a, AutogradValue) <span class="cf">else</span> <span class="fl">1.</span> <span class="op">/</span> (<span class="fl">1.</span> <span class="op">+</span> exp(<span class="op">-</span>x))</span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> NeuralNetwork:</span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, dims, hidden_sizes<span class="op">=</span>[]):</span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Create a list of all layer dimensions (including input and output)</span></span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>        sizes <span class="op">=</span> [dims] <span class="op">+</span> hidden_sizes <span class="op">+</span> [<span class="dv">1</span>]</span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Create each layer weight matrix (including bias dimension)</span></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.weights <span class="op">=</span> [np.random.normal(scale<span class="op">=</span><span class="fl">1.</span>, size<span class="op">=</span>(i <span class="op">+</span> <span class="dv">1</span>, o))</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a>                        <span class="cf">for</span> (i, o) <span class="kw">in</span> <span class="bu">zip</span>(sizes[:<span class="op">-</span><span class="dv">1</span>], sizes[<span class="dv">1</span>:])]</span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> prediction_function(<span class="va">self</span>, X, w):</span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a><span class="co">        Get the result of our base function for prediction (i.e. x^t w)</span></span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a><span class="co">        Args:</span></span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a><span class="co">            X (array): An N x d matrix of observations.</span></span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a><span class="co">            w (list of arrays): A list of weight matrices</span></span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns:</span></span>
<span id="cb18-30"><a href="#cb18-30" aria-hidden="true" tabindex="-1"></a><span class="co">            pred (array): An N x 1 matrix of f(X).</span></span>
<span id="cb18-31"><a href="#cb18-31" aria-hidden="true" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb18-32"><a href="#cb18-32" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Iterate through the weights of each layer and apply the linear function and activation</span></span>
<span id="cb18-33"><a href="#cb18-33" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> wi <span class="kw">in</span> w[:<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb18-34"><a href="#cb18-34" aria-hidden="true" tabindex="-1"></a>            X <span class="op">=</span> pad(X) <span class="co"># Only if we're using bias</span></span>
<span id="cb18-35"><a href="#cb18-35" aria-hidden="true" tabindex="-1"></a>            X <span class="op">=</span> sigmoid(matmul(X, wi))</span>
<span id="cb18-36"><a href="#cb18-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-37"><a href="#cb18-37" aria-hidden="true" tabindex="-1"></a>        <span class="co"># For the output layer, we don't apply the activation</span></span>
<span id="cb18-38"><a href="#cb18-38" aria-hidden="true" tabindex="-1"></a>        X <span class="op">=</span> pad(X)</span>
<span id="cb18-39"><a href="#cb18-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> matmul(X, w[<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb18-40"><a href="#cb18-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-41"><a href="#cb18-41" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> predict(<span class="va">self</span>, X):</span>
<span id="cb18-42"><a href="#cb18-42" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb18-43"><a href="#cb18-43" aria-hidden="true" tabindex="-1"></a><span class="co">        Predict labels given a set of inputs.</span></span>
<span id="cb18-44"><a href="#cb18-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-45"><a href="#cb18-45" aria-hidden="true" tabindex="-1"></a><span class="co">        Args:</span></span>
<span id="cb18-46"><a href="#cb18-46" aria-hidden="true" tabindex="-1"></a><span class="co">            X (array): An N x d matrix of observations.</span></span>
<span id="cb18-47"><a href="#cb18-47" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns:</span></span>
<span id="cb18-48"><a href="#cb18-48" aria-hidden="true" tabindex="-1"></a><span class="co">            pred (array): An N x 1 column vector of predictions in {0, 1}</span></span>
<span id="cb18-49"><a href="#cb18-49" aria-hidden="true" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb18-50"><a href="#cb18-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (<span class="va">self</span>.prediction_function(X, <span class="va">self</span>.weights) <span class="op">&gt;</span> <span class="dv">0</span>)</span>
<span id="cb18-51"><a href="#cb18-51" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-52"><a href="#cb18-52" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> predict_probability(<span class="va">self</span>, X):</span>
<span id="cb18-53"><a href="#cb18-53" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb18-54"><a href="#cb18-54" aria-hidden="true" tabindex="-1"></a><span class="co">        Predict the probability of each class given a set of inputs</span></span>
<span id="cb18-55"><a href="#cb18-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-56"><a href="#cb18-56" aria-hidden="true" tabindex="-1"></a><span class="co">        Args:</span></span>
<span id="cb18-57"><a href="#cb18-57" aria-hidden="true" tabindex="-1"></a><span class="co">            X (array): An N x d matrix of observations.</span></span>
<span id="cb18-58"><a href="#cb18-58" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns:</span></span>
<span id="cb18-59"><a href="#cb18-59" aria-hidden="true" tabindex="-1"></a><span class="co">            probs (array): An N x 1 column vector of predicted class probabilities</span></span>
<span id="cb18-60"><a href="#cb18-60" aria-hidden="true" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb18-61"><a href="#cb18-61" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> sigmoid(<span class="va">self</span>.prediction_function(X, <span class="va">self</span>.weights))</span>
<span id="cb18-62"><a href="#cb18-62" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-63"><a href="#cb18-63" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> accuracy(<span class="va">self</span>, X, y):</span>
<span id="cb18-64"><a href="#cb18-64" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb18-65"><a href="#cb18-65" aria-hidden="true" tabindex="-1"></a><span class="co">        Compute the accuracy of the model's predictions on a dataset</span></span>
<span id="cb18-66"><a href="#cb18-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-67"><a href="#cb18-67" aria-hidden="true" tabindex="-1"></a><span class="co">        Args:</span></span>
<span id="cb18-68"><a href="#cb18-68" aria-hidden="true" tabindex="-1"></a><span class="co">            X (array): An N x d matrix of observations.</span></span>
<span id="cb18-69"><a href="#cb18-69" aria-hidden="true" tabindex="-1"></a><span class="co">            y (array): A length N vector of labels.</span></span>
<span id="cb18-70"><a href="#cb18-70" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns:</span></span>
<span id="cb18-71"><a href="#cb18-71" aria-hidden="true" tabindex="-1"></a><span class="co">            acc (float): The accuracy of the classifier</span></span>
<span id="cb18-72"><a href="#cb18-72" aria-hidden="true" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb18-73"><a href="#cb18-73" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> y.reshape((<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb18-74"><a href="#cb18-74" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (<span class="va">self</span>.predict(X) <span class="op">==</span> y).mean()</span>
<span id="cb18-75"><a href="#cb18-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-76"><a href="#cb18-76" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> nll(<span class="va">self</span>, X, y, w<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb18-77"><a href="#cb18-77" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb18-78"><a href="#cb18-78" aria-hidden="true" tabindex="-1"></a><span class="co">        Compute the negative log-likelihood loss.</span></span>
<span id="cb18-79"><a href="#cb18-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-80"><a href="#cb18-80" aria-hidden="true" tabindex="-1"></a><span class="co">        Args:</span></span>
<span id="cb18-81"><a href="#cb18-81" aria-hidden="true" tabindex="-1"></a><span class="co">            X (array): An N x d matrix of observations.</span></span>
<span id="cb18-82"><a href="#cb18-82" aria-hidden="true" tabindex="-1"></a><span class="co">            y (array): A length N vector of labels.</span></span>
<span id="cb18-83"><a href="#cb18-83" aria-hidden="true" tabindex="-1"></a><span class="co">            w (array, optional): A (d+1) x 1 matrix of weights.</span></span>
<span id="cb18-84"><a href="#cb18-84" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns:</span></span>
<span id="cb18-85"><a href="#cb18-85" aria-hidden="true" tabindex="-1"></a><span class="co">            nll (float): The NLL loss</span></span>
<span id="cb18-86"><a href="#cb18-86" aria-hidden="true" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb18-87"><a href="#cb18-87" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> w <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb18-88"><a href="#cb18-88" aria-hidden="true" tabindex="-1"></a>            w <span class="op">=</span> <span class="va">self</span>.weights</span>
<span id="cb18-89"><a href="#cb18-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-90"><a href="#cb18-90" aria-hidden="true" tabindex="-1"></a>        y <span class="op">=</span> y.reshape((<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>))</span>
<span id="cb18-91"><a href="#cb18-91" aria-hidden="true" tabindex="-1"></a>        xw <span class="op">=</span> <span class="va">self</span>.prediction_function(X, w)</span>
<span id="cb18-92"><a href="#cb18-92" aria-hidden="true" tabindex="-1"></a>        py <span class="op">=</span> sigmoid((<span class="dv">2</span> <span class="op">*</span> y <span class="op">-</span> <span class="dv">1</span>) <span class="op">*</span> xw)</span>
<span id="cb18-93"><a href="#cb18-93" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span>(log(py)).<span class="bu">sum</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="q5" class="level4">
<h4 class="anchored" data-anchor-id="q5">Q5</h4>
<p>Implement an <code>nll_and_grad</code> method for the <code>NeuralNetwork</code> class using your reverse-mode automatic differentiation implmentation to compute the gradient with respect to each weight matrix.</p>
<p><em><strong>Hint:</strong> You’ll need to use the <code>wrap_array</code> and <code>unwrap_gradients</code> functions you wrote above. You should use the built-in <code>nll</code> method to compute the loss.</em></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> nll_and_grad(<span class="va">self</span>, X, y):</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Get the negative log-likelihood loss and its gradient</span></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a><span class="co">        X (array): An N x d matrix of observations.</span></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a><span class="co">        y (array): A length N vector of labels</span></span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a><span class="co">        nll (float): The negative log-likelihood</span></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a><span class="co">        grads (list of arrays): A list of the gradient of the nll with respect</span></span>
<span id="cb19-11"><a href="#cb19-11" aria-hidden="true" tabindex="-1"></a><span class="co">                                to each value in self.weights.</span></span>
<span id="cb19-12"><a href="#cb19-12" aria-hidden="true" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb19-13"><a href="#cb19-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">## YOUR CODE HERE</span></span>
<span id="cb19-14"><a href="#cb19-14" aria-hidden="true" tabindex="-1"></a>    loss <span class="op">=</span></span>
<span id="cb19-15"><a href="#cb19-15" aria-hidden="true" tabindex="-1"></a>    grads <span class="op">=</span></span>
<span id="cb19-16"><a href="#cb19-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> loss.value, grads</span>
<span id="cb19-17"><a href="#cb19-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-18"><a href="#cb19-18" aria-hidden="true" tabindex="-1"></a>NeuralNetwork.nll_and_grad <span class="op">=</span> nll_and_grad</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We now have everything in place to train a neural network from scratch! Let’s try it on our tiny dataset. Feel free to change the inputs.</p>
<p><em><strong>Hint</strong>: If this give very poor results and/or runs very slowly, make sure to carefully check the shape of each operation in your code to make sure it matches your expectation.</em></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>X, y <span class="op">=</span> make_moons(<span class="dv">100</span>, noise<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> NeuralNetwork(<span class="dv">2</span>, [<span class="dv">5</span>, <span class="dv">5</span>])</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>gradient_descent(model, X, y, lr<span class="op">=</span><span class="fl">3e-2</span>, steps<span class="op">=</span><span class="dv">250</span>)</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Model accuracy: </span><span class="sc">%.3f</span><span class="st">'</span> <span class="op">%</span> model.accuracy(X, y))</span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a>plot_boundary(model, X, y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
</section>
<section id="part-3-vectorizing-reverse-mode-automatic-differentiation" class="level2">
<h2 class="anchored" data-anchor-id="part-3-vectorizing-reverse-mode-automatic-differentiation">Part 3: Vectorizing Reverse-mode automatic differentiation</h2>
<p>We might notice that our reverse-mode automatic differentiation implementation is quite slow! The main reason for this is that our implementation operates on individual numbers (scalars) rather than entire arrays. This means that for a big operation like a matrix multiplication, an <code>AutogradValue</code> object needs to be tracked for each of the <span class="math inline">\(O(n^3)\)</span> individual operations! Even worse, it also means that internally Numpy can’t use the very fast C and C++ implementations it has for array operations on type <code>float</code>, our array elements are now objects so it has to fall back on slow Python-loop based implementations.</p>
<p>Ideally we’d like our <code>AutogradValue</code> objects to operate at the level of array operations, rather than scalar operations. This would circumvent these problems as we could represent an entire matrix multiplication with a single <code>AutogradValue</code>. In order to do this efficiently, we’ll need to make use of the <em>Vector-Jacobian Product</em> idea that we discussed in class. Let’s review the concept here.</p>
<p>Recall that in <code>backward_pass</code> for a node <code>c</code> we assume that we have the gradient (derivative) of the loss with respect to <code>c</code>: <span class="math inline">\(\frac{dL}{d\mathbf{c}}\)</span> and we need to update the gradients for the parents (say <code>a</code> and <code>b</code>) as:</p>
<p><span class="math display">\[\frac{dL}{da} = \frac{dL}{dc} \frac{dc}{da}, \quad \frac{dL}{dc} = \frac{dL}{dc} \frac{dc}{db}\]</span></p>
<p>When <span class="math inline">\(\mathbf{a}\)</span>, <span class="math inline">\(\mathbf{b}\)</span> and <span class="math inline">\(\mathbf{c}\)</span> are vectors the derivates <span class="math inline">\(\frac{d\mathbf{c}}{d\mathbf{a}}\)</span> and <span class="math inline">\(\frac{d\mathbf{c}}{d\mathbf{b}}\)</span> are <em>Jacobian matrices</em> with possibly many entries and our updates become vector-Jacobian products:</p>
<p><span class="math display">\[\frac{dL}{d\mathbf{a}} = \bigg(\frac{dL}{d\mathbf{c}}^T \frac{d\mathbf{c}}{d\mathbf{a}}\bigg)^T, \quad \frac{dL}{d\mathbf{b}} = \bigg(\frac{dL}{d\mathbf{c}}^T \frac{d\mathbf{c}}{d\mathbf{b}}\bigg)^T\]</span></p>
<p>However we often don’t need to actually construct the Jacobians fully to compute these products, as is the case for element-wise operations. As long as we can compute the correct values for <span class="math inline">\(\frac{dL}{d\mathbf{a}}\)</span>, we’re good! For example if <span class="math display">\[\mathbf{c} = \mathbf{a}^2, \quad \mathbf{c} = \begin{bmatrix} a_1^2 \\ a_2^2 \\ a_3^2 \\ \vdots \end{bmatrix}\]</span></p>
<p>We can easily see that we can just update the derivate for each element of <span class="math inline">\(\mathbf{a}\)</span> independently. <span class="math display">\[\frac{dL}{d\mathbf{a}} =  \begin{bmatrix} \frac{dL}{dc_1} \cdot 2 a_1 \\  \frac{dL}{dc_2} \cdot 2 a_2 \\  \frac{dL}{dc_3} \cdot 2 a_3 \\ \vdots  \end{bmatrix} = 2 \mathbf{a} \odot \frac{dL}{d\mathbf{c}}\]</span></p>
<p>If we want to be more formal we can note that technically, the Jacobian <span class="math inline">\(\frac{d\mathbf{c}}{d\mathbf{a}}\)</span> is diagonal (<span class="math inline">\(\frac{\partial c_i}{\partial a_j}\)</span> is only nonzeros for <span class="math inline">\(i=j\)</span>). Therefore we can write the <em>Vector-Jacobian Product</em> as:</p>
<p><span class="math display">\[\frac{dL}{d\mathbf{a}}^T = \frac{dL}{d\mathbf{c}}^T \frac{d\mathbf{c}}{d\mathbf{a}}  = \begin{bmatrix} \frac{dL}{dc_1} \\  \frac{dL}{dc_2} \\  \frac{dL}{dc_3} \\ \vdots  \end{bmatrix}^T \begin{bmatrix} 2 a_1 &amp; 0 &amp; 0 &amp; \dots \\0  &amp; 2 a_2 &amp; 0 &amp; \dots \\ 0 &amp; 0 &amp; 2 a_3 &amp; \dots \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots \end{bmatrix} =  \begin{bmatrix} \frac{dL}{dc_1} \cdot 2 a_1 \\  \frac{dL}{dc_2} \cdot 2 a_2 \\  \frac{dL}{dc_3} \cdot 2 a_3 \\ \vdots  \end{bmatrix}^T = \bigg(2 \mathbf{a} \odot \frac{dL}{d\mathbf{c}}\bigg)^T\]</span></p>
<p>For the case of addition, things are even simpler! If: <span class="math display">\[\mathbf{c} = \mathbf{a} + \mathbf{b}\]</span></p>
<p>We can again see that we can just update the derivative for each element of <span class="math inline">\(\mathbf{a}\)</span> independently, but this time each local derivative (<span class="math inline">\(\frac{dc_i}{da_i}\)</span>) is just <span class="math inline">\(1\)</span>, so <span class="math display">\[\frac{dL}{d\mathbf{a}} =  \begin{bmatrix} \frac{dL}{dc_1} \cdot 1 \\  \frac{dL}{dc_2} \cdot 1 \\  \frac{dL}{dc_3} \cdot 1 \\ \vdots  \end{bmatrix} = \frac{dL}{d\mathbf{c}}\]</span></p>
<p>In this case the Jacobian <span class="math inline">\(\frac{d\mathbf{c}}{d\mathbf{a}}\)</span> is simply the identity matrix, so: <span class="math display">\[\frac{dL}{d\mathbf{a}}^T =  \begin{bmatrix} \frac{dL}{dc_1} \\  \frac{dL}{dc_2} \\  \frac{dL}{dc_3} \\ \vdots  \end{bmatrix}^T \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; \dots \\0  &amp; 1 &amp; 0 &amp; \dots \\ 0 &amp; 0 &amp; 1 &amp; \dots \\ \vdots &amp; \vdots &amp; \vdots &amp; \ddots \end{bmatrix}= \frac{dL}{d\mathbf{c}}^T \mathbf{I} = \frac{dL}{d\mathbf{c}}^T\]</span></p>
<section id="q6" class="level4">
<h4 class="anchored" data-anchor-id="q6">Q6</h4>
<p>Let’s replace our operation implementations above with ones that compute <em>Vector-Jacobian products</em>. We’ll start with element-wise operations. Complete the <code>vjp</code> function for each operation below. Unlike the <code>grads</code> methods we implemented before which computed the derivative of the output with respect to each input: <span class="math inline">\(\frac{dc}{da}\)</span> and <span class="math inline">\(\frac{dc}{db}\)</span> (if applicable), each <code>vjp</code> method should directly compute the gradient of the <em>loss</em> with respect to each input: <span class="math inline">\(\frac{dL}{d\mathbf{a}}\)</span> and <span class="math inline">\(\frac{dL}{d\mathbf{b}}\)</span>, assuming the <code>grad</code> argument provides the gradient of the loss with respect to the output: <span class="math inline">\(\frac{dL}{d\mathbf{c}}\)</span>.</p>
<p><em><strong>Hint:</strong> For binary operations (+,-,*,/), you do <strong>not</strong> need to account for broadcasting. That is, you can assume that <code>a</code>, <code>b</code> and <code>c</code> are always the same shape! We’ve started you off with a few examples to base your answers on.</em></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> _add(AutogradValue):</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a>    <span class="co"># An example representing the addition operation.</span></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> func(<span class="va">self</span>, a, b):</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a><span class="co">        Computes the result of the operation (a + b). Assumes a and b are the same shape.</span></span>
<span id="cb21-6"><a href="#cb21-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-7"><a href="#cb21-7" aria-hidden="true" tabindex="-1"></a><span class="co">        Args:</span></span>
<span id="cb21-8"><a href="#cb21-8" aria-hidden="true" tabindex="-1"></a><span class="co">            a (array of float): The first operand</span></span>
<span id="cb21-9"><a href="#cb21-9" aria-hidden="true" tabindex="-1"></a><span class="co">            b (array of float): The second operand</span></span>
<span id="cb21-10"><a href="#cb21-10" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns:</span></span>
<span id="cb21-11"><a href="#cb21-11" aria-hidden="true" tabindex="-1"></a><span class="co">            c (array of float): The result c = a + b</span></span>
<span id="cb21-12"><a href="#cb21-12" aria-hidden="true" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb21-13"><a href="#cb21-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a <span class="op">+</span> b</span>
<span id="cb21-14"><a href="#cb21-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-15"><a href="#cb21-15" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> vjp(<span class="va">self</span>, grad, a, b):</span>
<span id="cb21-16"><a href="#cb21-16" aria-hidden="true" tabindex="-1"></a>        <span class="co">'''</span></span>
<span id="cb21-17"><a href="#cb21-17" aria-hidden="true" tabindex="-1"></a><span class="co">        Computes dL/da and dL/db given dL/dc.</span></span>
<span id="cb21-18"><a href="#cb21-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-19"><a href="#cb21-19" aria-hidden="true" tabindex="-1"></a><span class="co">        Args:</span></span>
<span id="cb21-20"><a href="#cb21-20" aria-hidden="true" tabindex="-1"></a><span class="co">            grad (array of float): The gradient of the loss with respect to the output (dL/dc)</span></span>
<span id="cb21-21"><a href="#cb21-21" aria-hidden="true" tabindex="-1"></a><span class="co">            a (array of float): The first operand</span></span>
<span id="cb21-22"><a href="#cb21-22" aria-hidden="true" tabindex="-1"></a><span class="co">            b (array of float): The second operand</span></span>
<span id="cb21-23"><a href="#cb21-23" aria-hidden="true" tabindex="-1"></a><span class="co">        Returns:</span></span>
<span id="cb21-24"><a href="#cb21-24" aria-hidden="true" tabindex="-1"></a><span class="co">            grads (tuple of arrays): A tuple containing the gradients dL/da and dL/db</span></span>
<span id="cb21-25"><a href="#cb21-25" aria-hidden="true" tabindex="-1"></a><span class="co">        '''</span></span>
<span id="cb21-26"><a href="#cb21-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> grad, grad</span>
<span id="cb21-27"><a href="#cb21-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-28"><a href="#cb21-28" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> _square(AutogradValue):</span>
<span id="cb21-29"><a href="#cb21-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Another example class implementing c = a^2</span></span>
<span id="cb21-30"><a href="#cb21-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> func(<span class="va">self</span>, a):</span>
<span id="cb21-31"><a href="#cb21-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a <span class="op">**</span> <span class="dv">2</span></span>
<span id="cb21-32"><a href="#cb21-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-33"><a href="#cb21-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> vjp(<span class="va">self</span>, grad, a):</span>
<span id="cb21-34"><a href="#cb21-34" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (<span class="dv">2</span> <span class="op">*</span> a <span class="op">*</span> grad,)</span>
<span id="cb21-35"><a href="#cb21-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-36"><a href="#cb21-36" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> _pad(AutogradValue):</span>
<span id="cb21-37"><a href="#cb21-37" aria-hidden="true" tabindex="-1"></a>    <span class="co"># An implementation for padding with a column of 1s.</span></span>
<span id="cb21-38"><a href="#cb21-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> func(<span class="va">self</span>, a):</span>
<span id="cb21-39"><a href="#cb21-39" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.pad(a, ((<span class="dv">0</span>, <span class="dv">0</span>), (<span class="dv">0</span>, <span class="dv">1</span>)), constant_values<span class="op">=</span><span class="fl">1.</span>, mode<span class="op">=</span><span class="st">'constant'</span>)</span>
<span id="cb21-40"><a href="#cb21-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-41"><a href="#cb21-41" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> vjp(<span class="va">self</span>, grad, a):</span>
<span id="cb21-42"><a href="#cb21-42" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> (grad[:, :<span class="op">-</span><span class="dv">1</span>],)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> _sub(AutogradValue):</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> func(<span class="va">self</span>, a, b):</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a <span class="op">-</span> b</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> vjp(<span class="va">self</span>, grad, a, b):</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>        <span class="co"># YOUR CODE HERE</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> _neg(AutogradValue):</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> func(<span class="va">self</span>, a):</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="op">-</span>a</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> vjp(<span class="va">self</span>, grad, a):</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>        <span class="co"># YOUR CODE HERE</span></span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> _mul(AutogradValue):</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> func(<span class="va">self</span>, a, b):</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a <span class="op">*</span> b</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> vjp(<span class="va">self</span>, grad, a, b):</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>        <span class="co"># YOUR CODE HERE</span></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> _div(AutogradValue):</span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> func(<span class="va">self</span>, a, b):</span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> a <span class="op">/</span> b</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> vjp(<span class="va">self</span>, grad, a, b):</span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>        <span class="co"># YOUR CODE HERE</span></span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> _exp(AutogradValue):</span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> func(<span class="va">self</span>, a):</span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.exp(a)</span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> vjp(<span class="va">self</span>,grad,  a):</span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true" tabindex="-1"></a>        <span class="co"># YOUR CODE HERE</span></span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> _log(AutogradValue):</span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> func(<span class="va">self</span>, a):</span>
<span id="cb22-38"><a href="#cb22-38" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.log(a)</span>
<span id="cb22-39"><a href="#cb22-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-40"><a href="#cb22-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> vjp(<span class="va">self</span>, grad, a):</span>
<span id="cb22-41"><a href="#cb22-41" aria-hidden="true" tabindex="-1"></a>        <span class="co"># YOUR CODE HERE</span></span>
<span id="cb22-42"><a href="#cb22-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-43"><a href="#cb22-43" aria-hidden="true" tabindex="-1"></a>test_vjp(_neg, <span class="st">'_neg'</span>, )</span>
<span id="cb22-44"><a href="#cb22-44" aria-hidden="true" tabindex="-1"></a>test_vjp(_exp, <span class="st">'_exp'</span>, true_func<span class="op">=</span>anp.exp)</span>
<span id="cb22-45"><a href="#cb22-45" aria-hidden="true" tabindex="-1"></a>test_vjp(_log, <span class="st">'_log'</span>, true_func<span class="op">=</span>anp.log)</span>
<span id="cb22-46"><a href="#cb22-46" aria-hidden="true" tabindex="-1"></a>test_vjp(_sub, <span class="st">'_sub'</span>, <span class="va">True</span>)</span>
<span id="cb22-47"><a href="#cb22-47" aria-hidden="true" tabindex="-1"></a>test_vjp(_mul, <span class="st">'_mul'</span>, <span class="va">True</span>)</span>
<span id="cb22-48"><a href="#cb22-48" aria-hidden="true" tabindex="-1"></a>test_vjp(_div, <span class="st">'_div'</span>, <span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="q7" class="level4">
<h4 class="anchored" data-anchor-id="q7">Q7</h4>
<p>Consider the operation defined by <code>np.sum</code>, that takes the sum over all elements of a matrix or vector, producing a scalar:</p>
<p><span class="math display">\[c  = \sum_{i=1}^n a_i\]</span></p>
<p>Write a <code>vjp</code> method for this operation that computes: <span class="math inline">\(\frac{dL}{d\mathbf{a}}\)</span> given <span class="math inline">\(\frac{dL}{dc}\)</span>.</p>
<p><em><strong>Hint:</strong> Note that <span class="math inline">\(L\)</span>, <span class="math inline">\(c\)</span> and <span class="math inline">\(\frac{dL}{dc}\)</span> are all scalars, so for any entry <span class="math inline">\(i\)</span> of our output we can simply apply the chain rule and compute <span class="math inline">\(\frac{dL}{da_i} = \frac{dL}{dc} \frac{dc}{da_i}\)</span>. As the equation above for <span class="math inline">\(c\)</span> given <span class="math inline">\(\mathbf{a}\)</span> is a sum, <span class="math inline">\(\frac{dc}{da_i}\)</span> should be simple!</em></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> _sum(AutogradValue):</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> func(<span class="va">self</span>, a):</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.<span class="bu">sum</span>(a)</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> vjp(<span class="va">self</span>, grad, a):</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>        <span class="co"># YOUR CODE HERE</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>test_vjp(_sum, <span class="st">'_sum'</span>, true_func<span class="op">=</span>anp.<span class="bu">sum</span>, issum<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="matrix-multiplication" class="level3">
<h3 class="anchored" data-anchor-id="matrix-multiplication">Matrix multiplication</h3>
<p>For the next few problems, it may be useful to refer to this diagram of matrix multiplication.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="data:image/png;base64,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hu22k/0w2ksYYgeyN9lo/g6bZCdhh93JVpI3EYN9zIZga+wlYa1tbLL77rtvbpc8iDoEBrbYqoQJO2oE/agHm2esRMGdLcfGuvfee2dew25mC2u/+4k+6qC/scRR+dqnLuwl7fUcsAddP/rBfeohDWGHGOR797oPe3UaAo+yH3/88bnezpWFBVsM+3EM23DY/ezOIdp5FocNR7xbTNufF88Ce1Z+yvO7hA9/Qfnq7HnRVn3quwSeRaqdRyACEYhABCIQgQgcJIFT85AOsibldWQJcKI44xy0r371q29MvnNmRbONw3UcMo4eJ4eTduONN84RjE888cQWYcekOSHBJPpeEwfTwVn71re+NTu5HF3149SpD2dMfTiHnF914pRxfq+++urpj//4j6frr7/+DUdysQ6cXQ7dk08+OX3ta1+bRRJ5K0++WIwJDM4eJ93BuSMu3HDDDXP+ohCVuVdhR/1NQjz66KPTV77ylfmcI8mJlidHclXSL//v//2/6Zvf/ObMXjs5tSYY1EX+Jlq+/e1vz/lrK6EGG23XTo6tyQs8fYf3ED3kc+21107XXHPNfNhq5X//7/895+dcPZUx+GOvnznZhJdPfepT05/8yZ/M0bHDeXetOv393//93Kd4cvTlI+mHp59++t/076iT542T/ZnPfGa69dZb5z7YLuxo11133TU/Lw888MD8vJik0aejjeqDkX4dAs/HP/7x6Y/+6I+mm2++eXJOSCpFIAIRiEAETioBY7ax0xhK0GBHWPVgzCakmMAXmEJYIf74fthlY9w2yc6W+Mu//MvplltumW2bdYEr63grl60gSOQf/uEfZjGCTTJsQ3Vkz4xxnp2gTPYD24TN+slPfvLfBIZoL7uPkMC+kv9jjz02CwDaNQ55sx+GDUEcYfto5xe+8IXZZtqPEKDe2kAsYSc9/PDDs1172223zfVV/1VJwI/+YBfqE3YcO0sfEEnYPjgRNr76up3PBmSnC/phC+tDdpN71QMLdhOO8iEUEXfYm+w7HP7u7/5utp/Zdsr3DLhHGvcRcti0+v8//+f/PPNhM3pGJALSPffcM919992zTepafaHMO+64Y+5rfe45lL961VP6AABAAElEQVTftAV/faudbH59+8UvfnG20eeM//Uf92ofX2I8L57l0Ub5SeqrTspl17PJtVW9P/3pT8+f/zXL/kQg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8MorrwyvvfbacPLJJw+ffPLJePZCnvX0XpnG3XRsu3fvHsff97ZV2STYOQw3pFMQIHBAAkcf0N52JkCAAAECBAgQIECAAAECBAgQIEBg1QtMQUYBxqeffjpW6px55plD6wknnDCGOusp2Fn1F9QACBBYVwKCnXV1uQ2WAAECBAgQIECAAAECBAgQIECAwDCGOW+++eZYpVKwc9xxx42hzllnnTWGPEIddwkBAgRmV0CwM7vXRs8IECBAgAABAgQIECBAgAABAgQIrIjA3IqdvvdunbPPPnuYgp0VOalGCRAgQGBZBLxjZ1kYNUKAAAECBAgQIECAAAECBAgQIEDgyAl88cUXQ+/Nqfrm448/Ht8P0/e2H3300WNFTlOsnXjiiePab03DVtVO3wt2CnUKd/p+qMvUn0Kjae08vbOmaqDe4XPssceO0771bp8qhurn/lQK9c6bzz///Jtx1n5jb1tL7bbWZmNp3P19KEv9rv3GkG9/N4bOkemGDXt/zNpxH3zwwXj81Mdp3I259qbr13ga49xx9Hfnndb60rb6MI3xpJNOGo+pvX7rGnTejz76aDyu79P9UH/nHtc4Flvm9rt261P97rz91jr3fpv6NLlk33n25TP1tbF/+OGH4z0zjbHzdm9Mfe78U5tttxBYjwJ7/xdnPYoYMwECBAgQIECAAAECBAgQIECAAIFVJNDD9EKBd999dwxrXnvtteGNN94Yv/egvIfsmzZtGi644IJv1h7IF+y0tk+hQMHOclXs1J933nlnbP/1118fA6S33357PFcP6Hvgv3HjxuHcc88dLr300vG8hQYFBntbGmtrD/9feeWVb8bZ2N97770xGDrttNPG8fa+oIKq8847bwwFCggOdilkeP/994fGkG9hRmZnnHHGaHrqqafutelCnWeffXY0qf9dj8Z9+umnj6FFXvW/9vPqfPm0X+Po78b76quvjr+3b2FIjuecc85w/vnnDxdffPG4f4b9llHtvfzyy2OfC/Hqd871t2vdPbF58+ZvAqG5g6ifjbl+55tf/a3fnbfrW5v1qfutv+tnQVcuF1544WjfNd5XsNP92PHZvvDCC2O7nbv25gY6jXXLli3jmKdgbG6ffSewXgQEO+vlShsnAQIECBAgQIAAAQIECBAgQIDAmhHooXtVHgUGBQE9EO8Be+vcYKcH5j3In4KdHspf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aSFAYP0JCHbW3zU3YgIECBAgQIAAAQIECBAgQIAAgVUqsGnTpmHLli1Dn5aDF9jy+anDbZ9cOFz69edqXLr+7205ebhow3ursfv6TOCQBN59991h165dQ5/rdRHsrNcrb9wECBAgQIAAAQIECBAgQIAAAQKrTqBQ5yc/+clw0003rbq+z1KHj3rm7eGof3p6GHa+NUvd2u++dB/89D/9YPjqsjP2+xg7ElgrAg8//PDwN3/zN0Of63UR7KzXK2/cBAgQIECAAAECBAgQIECAAAECq06gSo1Cne9+97urru+z1OE9pzwzPP/b14c9w+oMdjZt2jhccuONw8bbLpslVn0hcNgE/u7v/u6wnWsWT3T0LHZKnwgQIECAAAECBAgQIECAAAECBAgQIECAAAECBBYKCHYWmthCgAABAgQIECBAgAABAgQIECBAgAABAgQIEJhJAcHOTF4WnSJAgAABAgQIECBAgAABAgQIECBAgAABAgQILBQQ7Cw0sYUAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgMJMCgp2ZvCw6RYAAAQIECBAgQIAAAQIECBAgQIAAAQIECBBYKCDYWWhiCwECBAgQIECAAAECBAgQIECAAAECBAgQIEBgJgUEOzN5WXSKAAECBAgQIECAAAECBAgQIECAAAECBAgQILBQQLCz0MQWAgQIECBAgAABAgQIECBAgAABAgQIECBAgMBMCgh2ZvKy6BQBAgQIECBAgAABAgQIECBAgAABAgQIECBAYKGAYGehiS0ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgZkUEOzM5GXRKQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIDAQgHBzkITWwgQIECAAAECBAgQIECAAAECBAgQIECAAAECMykg2JnJy6JTBAgQIECAAAECBAgQIECAAAECBAgQIECAAIGFAoKdhSa2ECBAgAABAgQIECBAgAABAgQIECBAgAABAgRmUkCwM5OXRacIECBAgAABAgQIECBAgAABAgQIECBAgAABAgsFBDsLTWwhQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECMykgGBnJi+LThEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEFgoIdhaa2EKAAAECBAgQIECAAAECBAgQIECAAAECBAgQmEkBwc5MXhadIkCAAAECBAgQIECAAAECBAgQIECAAAECBAgsFBDsLDSxhQABAgQIECBAgAABAgQIECBAgAABAgQIECAwkwKCnZm8LDpFgAABAgQIECBAgAABAgQIECBAgAABAgQIEFgoINhZaGILAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQGAmBQQ7M3lZdIoAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgsFBAsLPQxBYCBAgQIECAAAECBAgQIECAAAECBAgQIECAwEwKCHZm8rLoFAECBAgQIECAAAECBAgQIECAAAECBAgQIEBgoYBgZ6GJLQQIECBAgAABAgQIECBAgAABAgQIECBAgACBmRQQ7MzkZdEpAgQIECBAgAABAgQIECBAgAABAgQIECBAgMBCAcHOQhNbCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIzKSDYmcnLolMECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgYUCgp2FJrYQIECAAAECBAgQIECAAAECBAgQIECAAAECBGZSQLAzk5dFpwgQIECAAAECBAgQIECAAAECBAgQIECAAAECCwUEOwtNbCFAgAABAgQIECBAgAABAgQIECBAgAABAgQIzKSAYGcmL4tOESBAgAABAgQIECBAgAABAgQIECBAgAABAgQWCgh2FprYQoAAAQIECBAgQIAAAQIECBAgQIAAAQIECBCYSQHBzkxeFp0iQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECCwUEOwsNLGFAAECBAgQIECAAAECBAgQIECAAAECBAgQIDCTAoKdmbwsOkWAAAECBAgQIECAAAECBAgQIECAAAECBAgQWCgg2FloYgsBAgQIECBAgAABAgQIECBAgAABAgQIECBAYCYFBDszeVl0igABAgQIECBAgAABAgQIECBAgAABAgQIECCwUECws9DEFgIECBAgQIAAAQIECBAgQIAAAQIECBAgQIDATAoIdmbysugUAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQGChgGBnoYktBAgQIECAAAECBAgQIECAAAECBAgQIECAAIGZFBDszORl0SkCBAgQIECAAAECBAgQIECAAAECBAgQIECAwEIBwc5CE1sIECBAgAABAgQIECBAgAABAgQIECBAgAABAjMpINiZycuiUwQIECBAgAABAgQIECBAgAABAgQIECBAgACBhQKCnYUmthAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEZlJAsDOTl0WnCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQILBQQ7C01sIUCAAAECBAgQIECAAAECBAgQIECAAAECBAjMpIBgZyYvi04RIECAAAECBAgQIECAAAECBAgQIECAAAECBBYKCHYWmthCgAABAgQIECBAgAABAgQIECBAgAABAgQIEJhJAcHOTF4WnSJAgAABAgQIECBAgAABAgQIECBAgAABAgQILBQQ7Cw0sYUAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgMJMCgp2ZvCw6RYAAAQIECBAgQIAAAQIECBAgQIAAAQIECBBYKCDYWWhiCwECBAgQIECAAAECBAgQIECAAAECBAgQIEBgJgUEOzN5WXSKAAECBAgQIECAAAECBAgQIECAAAECBAgQILBQQLCz0MQWAgQIECBAgAABAgQIECBAgAABAgQIECBAgMBMCgh2ZvKy6BQBAgQIECBAgAABAgQIECBAgAABAgQIECBAYKGAYGehiS0ECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgZkUEOzM5GXRKQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIDAQgHBzkITWwgQIECAAAECBAgQIECAAAECBAgQIECAAAECMykg2JnJy6JTBAgQIECAAAECBAgQIECAAAECBAgQIECAAIGFAoKdhSa2ECBAgAABAgQIECBAgAABAgQIECBAgAABAgRmUkCwM5OXRacIECBAgAABAgQIECBAgAABAgQIECBAgAABAgsFBDsLTWwhQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECMykgGBnJi+LThEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEFgoIdhaa2EKAAAECBAgQIECAAAECBAgQIECAAAECBAgQmEkBwc5MXhadIkCAAAECBAgQIECAAAECBAgQIECAAAECBAgsFBDsLDSxhQABAgQIECBAgAABAgQIECBAgAABAgQIECAwkwKCnZm8LDpFgAABAgQIECBAgAABAgQIECBAgAABAgQIEFgoINhZaGILAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQGAmBQQ7M3lZdIoAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgsFBAsLPQxBYCBAgQIECAAAECBAgQIECAAAECBAgQIECAwEwKCHZm8rLoFAECBAgQIECAAAECBAgQIECAAAECBAgQIEBgocCGhZtsIbD+BL766qvhD3/4w/Dyyy+Pnwm0bW/LMcccM2zYsGE47bTThvPOO2845ZRT9rb7Pn/7/PPPh48++mj48ssvx3Zr+9hjjx2OPno28tf3339/ePXVV4dPPvlkOPnkk8fxnnrqqcPxxx+/z7EttsPHH3887NmzZ/jggw+Gvp9wwgnDueeeO7a92P62ESBAgAABAgQIECBAgAABAgQIECBAgMAwCHbcBeteoACn9cUXXxz+9m//dti+fft+mRx33HFjuHHNNdcMP/zhD4fLL798v45baqdCnd27d4/BSYHJtB5scLLUeQ52e6HOz372s+HNN98cLr300nG827ZtO+hgp1DnscceG5599tnhtddeG0OdP//zPx+2bt16sF10HAECBAgQIECAAAECBAgQIECAAAECBNa8gGBnzV9iA9xfgXfeeWd4+OGHhwceeGA46aSTvlmrmllsKXCp0qRKn88++2yxXQ5oW+08+eSTY3vnn3/+cOGFFw6FR0c62Cn0qororbfeGh566KExhKmaqOqaqowOdqlSp1Dn8ccfH8OiKoE+/PDDg23OcQQIECBAgAABAgQIECBAgAABAgQIEFgXAoKddXGZDXJfAoUXhRRNN9bnmWeeOWzevHm46KKLxqnWFju+wOfEE08cLrnkkiX3Wey4pba9/fbbw7333jtOd1YVUP0444wzlqXtpc65P9sLdQqu3nvvvbFvBWCNvYqiAp6DXQrFXnnlleH1118fmtYuyz4tBAgQIECAAAECBAgQIECAAAECBAgQILC0wME/lV26Tb8QWJUCU4DRO23OOuuscaqxApazzz570fG0XwFH4Uvv1/niiy/GAKSQqIDiqKOOGitdCmiqRqn9tk9VOIUi7dtxn3766Vi18txzzw0vvfTS2N4555wzvoNm06ZN43nat/1aOm/nr83ab/vUfu1Oa31onbtM55v6WZ+m/s7db/pe+4U6BTrvvvvueK5CndNPP30cyzSG2m3flvpXm/Vx/vmndgt2CnUKtArQNm7cOB43/e6TAAECBAgQIECAAAECBAgQIECAAAECBBYKCHYWmtiyzgWa+qwwZ8uWLcPVV189XHDBBYuKTKFJQU1Tt1XVUvhR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p5xyyhj29JuFAAECBAgQIECAAAECBAgQIECAAAECBFa/gGBn9V9DIyAwCvRum9azzjqLCAECBAgQIECAAAECBAgQIECAAAECBAisUYGj1+i4DIsAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgsOYEBDtr7pIaEAECBAgQIECAAAECBAgQIECAAAECBAgQILBWBQQ7a/XKGhcBAgQIECBAgAABAgQIECBAgAABAgQIECCw5gQEO2vukhoQAQIECBAgQIAAAQIECBAgQIAAAQIECBAgsFYFBDtr9coaFwECBAgQIECAAAECBAgQIECAAAECBAgQILDmBAQ7a+6SGhABAgQIECBAgAABAgQIECBAgAABAgQIECCwVgUEO2v1yhoXAQIECBAgQIAAAQIECBAgQIAAAQIECBAgsOYEBDtr7pIaEAECBAgQIECAAAECBAgQIECAAAECBAgQILBWBQQ7a/XKGhcBAgQIECBAgAABAgQIECBAgAABAgQIECCw5gQEO2vukhoQAQIECBAgQIAAAQIECBAgQIAAAQIECBAgsFYFBDtr9coaFwECBAgQIECAAAECBAgQIECAAAECBAgQILDmBAQ7a+6SGhABAgQIECBAgAABAgQIECBAgAABAgQIECCwVgUEO2v1yhoXAQIECBAgQIAAAQIECBAgQIAAAQIECBAgsOYENqy5ERkQAQKHJPD5ex8Nn+x+Z+hzNS4bTj1xOP6C04c+LQQIECBAgMDqFjjlmOOH847bOJz69WfLls9PHY565u1hzynPrO6B6T0BAjMr0L8x/Vtz+YnnDK9+umd4/4tPZravOkaAAAECBAisXwHBzvq99kZOYFGBQp3X/r8Hhvef2r3o77O+8ZQrLxjO/c+3DRuuEuzM+rXSPwIECBAgsC+BQp0fnnnd+IC1fTd9smk46p+eHp7/7ev7OtTvBAgQOCiBo97dM/w/n1w4nPr1vz0/e+vxYedH/r05KEgHESBAgAABAisqINhZUV6NE1h9AlXqFOrseeDZ1df5f+/xmau02mjVgus4AQIECBBYIYEqdfr/mr/5lIv/7xk+//pj51vDnuGtFTqjZgkQWO8CR30NcOlw6vDu1//2TNWC693E+AkQIECAAIHZE/COndm7JnpEgAABAgQIECBAgAABAgQIECBAgAABAgQIEFhUQLCzKIuNBAgQIECAAAECBAgQIECAAAECBAgQIECAAIHZExDszN410SMCBAgQIECAAAECBAgQIECAAAECBAgQIECAwKICgp1FWWwkQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECMyegGBn9q6JHhEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEFhUQ7CzKYiMBAgQIECBAgAABAgQIECBAgAABAgQIECBAYPYEBDuzd030iAABAgQIECBAgAABAgQIECBAgAABAgQIECCwqIBgZ1EWGwkQIECAAAECBAgQIECAAAECBAgQIECAAAECsycg2Jm9a6JHBAgQIECAAAECBAgQIECAAAECBAgQIECAAIFFBTYsutVGAgQIECBAgACBZRX45JNPhvfee294//33hw8++GD47LPPlrX9A2nsqKOOGk466aTh7LPPHk455ZThmGOOGdpmIUCAAAECBAgQIECAAAECBGZfQLAz+9dIDwkQIECAAIE1IFCos2PHjmHnzp3Dc889N7zzzjtHZFQFOAU5l1xyyXD33XcPl1122XDiiScOGzb4PwuPyAVxUgIECBAgQIAAAQIECBAgcIAC/hf8AYLZnQABAgQIECBwMAIff/zxsHv37mH79u3Dww8/PLz22msH08whH1Owc/TRRw/XX3/9cMUVVwwXXHDBcNxxxwl2Dll2bTTwhz/8YbxPP/300+H0008fTj311OHkk08ejj322LUxQKMgQIAAAQIECBAgQIDAGhAQ7KyBi2gIBAgQIECAwOwLNPVaVTtvvPHG8PLLL4/rkep14c6mTZuGt956a/jwww/HB/fHH3/8keqO886IwFdffTXel//jf/yPYc+ePcPNN988bNu2bazu6n6xECBAgAABAgQIECBAgMBsCAh2ZuM66AUBAgQIECCwxgW+/PLLoffsFKRUFdGD8yO51IePPvpoqDKjvlnWt8AXX3wxvvepSrIHH3xwePfdd4fzzz9/2LJli/tjfd8aRk+AAAECBAgQIECAwAwKCHZm8KLoEgECBAgQILA2BaqUmaZC6/NILkf6/Edy7M69UODzzz8fA8equN58880x8OvdS6eddppp+hZy2UKAAAECBAgQIECAAIEjKiDYOaL8Tk6AAAECBAisF4Eekvc+m2uuuWZoyqvLLrvsiA79yiuvHPtz0kkneXB/AFeia9c6VbgUkPWOoj6bbq/tVUD1HqOm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a1dEfwgQIECAAAECBAgQIECAAAECBAgQIECAAAECSwgIdpaAsZkAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgMGsCG2atQ/pDgMCRFdhw6onDKVdecGQ7cQhnr++NwUKAAAECBAisfoH3vvhk2PnR698MZNOmTcOWLVuGTZs2frPNFwIECCynwLvv7hl27do1/tvTv0EWAgQIECBAgMAsCgh2ZvGq6BOBIyhw/AWnD+f+59uGM9/76Aj24uBPXajTGCwECBAgQIDA6hd49dM9w8/eenw49Zjjx8HceO5Nw0//0w+GS268cfUPzggIEJhJgXceeWT4l//318Ovvv63p3+DLAQIECBAgACBWRQQ7MziVdEnAkdQoGBkw1UqXo7gJXBqAgQIECBA4N8F3p9XsbNxw2XDV5edMWy87TJGBAgQWBGBr95/cdi14b1vVQuuyIk0SoAAAQIECBA4BAHv2DkEPIcSIECAAAECBAgQIECAAAECBAgQIECAAAECBA6ngGDncGo7FwECBAgQIECAAAECBAgQIECAAAECBAgQIEDgEAQEO4eA51ACBAgQIECAAAECBAgQIECAAAECBAgQIECAwOEUEOwcTm3nIkCAAAECBAgQIECAAAECBAgQIECAAAECBAgcgoBg5xDwHEqAAAECBAgQIECAAAECBAgQIECAAAECBAgQOJwCgp3Dqe1cBAgQIECAAAECBAgQIECAAAECBAgQIECAAIFDEBDsHAKeQwkQIECAAAECBAgQIECAAAECBAgQIECAAAECh1Ngw+E8mXMRIECAAAECBAgQIECAAAECBAgQWAmBL7/8cvjss8+Gr776ajjmmGPG9aijjhpa2/bJJ58M77333vDBBx+M37/44othw4YNw/HHHz+cdNJJw4knnjiccMIJ47aV6J82CRAgQIDAcgkIdpZLUjsECBAgQIAAAQIECBAgQIAAAQJHTKBQ5w9/+MNQYFNQU2Bz7LHHjv0p2NmzZ8/w+9//fti1a9fw2muvjeFO+5199tnD5s2bhwsvvHA4//zzh1NOOeWIjcGJCRAgQIDA/ggIdvZHyT4ECBAgQIAAAQIECBAgQIAAAQIzJVCAU5hTFc7rr78+vPnmm+Na1c3WrVuHc889dwxpPv/883H7008/Pdx///3Djh07xmDn008/HQOgs846a7jkkkuGK664Yrj++uuHiy66aDj55JOH4447bqbGqzMECBAgQGASEOxMEj4JECBAgAABAgQIECBAgAABAgRWjUChzlSF8y//8i/DE088MQY4F1988fCjH/1orNYpnHnnnXeG3/zmN8N99903PPDAA8MLL7wwfPzxx0NTt01TsRXkbNu2bZym7dZbbx0uvfRSwc6quRN0lAABAutPQLCz/q65ERMgQIAAAQIECBAgQIAAAQIEVrVAU6s17dr27duHe++9d/jlL385fi/oafudd945fPTRR+NaNc9DDz007le1TvtM07RVzdM7d15++eXhww8/HDZt2jS+a+fMM88cTj/99FVtpPMECBAgsHYFBDtr99oaGQECBAgQIECAAAECBAgQIEBgzQkU6rS+8sorw89//vPh3/7t38b35hTYFNQcddRRwzHHHDNW5BTatN+TTz45PPXUU8P7778/hjrnnHPOsHHjxvF7+7z44ovD22+/PVb0VL1z7bXXju/dqS0LAQIECBCYNQHBzqxdEf0hQIAAAQIECBAgQIDA/8/enfdGlZ95//+y24BtvOMFY2wwW7Onu0MymZ5kpJGSKIo0/4yUiTRP7TcPYEaTmVF+SqLRRJ10kg5N0zT7Dt4XjDcwmMXceV93DrehbbCxq1xVfh/ppMpVp06deh1Sdfp8znV9FVBAAQUUWFBgbpXNhQsXIrSZmZmJcXGam5vT0aNHU1NTU7Riow1bf39/zOPj4/EYzx0/fjzG0qFyZ3BwMDFeDwFQb29vunXrVrR0o4KH52nX5qSAAgoooEAhCfjLVEh7w21RQAEFFFBAAQUUUEABBRRQQAEFFHirAC3WCGGosrl//34i1GEsna6urvSjH/0o2rDt27cv1kFQw3KENJs2bUo1NTXp0KFD6ac//Wn64IMPorKHah6qdhh3hyCIeWhoKI2Ojqa6ujqDnbfuDZ9UQAEFFFgNAYOd1VD3PRVQQAEFFFBAAQUUUEABBRRQQAEF3kvg6dOnEegwdg6t1davX59orXbgwIEIdU6dOpW2b98e4Q8BDRU7hEHl5eWppaUllqOqh5mJtm4dHR2pu7s7xt8hBKK6h7F6aNfmpIACCiigQKEJrC+0DXJ7FFBAAQUUUEABBRRQQAEFFFBAAQUUWEjg2bNnEboQvNCWraKiIqp1qMShzRqhDu3TqMAh2GHmfrYclT3cz6aysrLU2NgYM/dpy0YFDzP3nRRQQAEFFCg0AYOdQtsjbo8CCiiggAIKKKCAAgoooIACCiigwIIChC1U1VCFw33CmJ07dybG16msrIy2bFTxEOYwfk4W7GzdujXt3r07tbW1Je5nEyEQYVAWCM3Oziaqgpi576SAAgoooEChCRjsFNoecXsUUEABBRRQQAEFFFBAAQUUUEABBRYUeDN42bBhQwQ1tFrjPhPt1eZW7DAOT1aZQwjE/bkTyy80z13O+woooIACChSCgGPsFMJecBsUUEABBRRQQAEFFFBAAQUUUEABBRYtQEXOunXrYnkCGVqyMXOfVm1U8zx48CDG4pmYmIjKG6p06uvrU21tbVT1ZG/G6xirh5n7rJcqHmbex0kBBRRQQIFCE/DXqdD2iNujgAIKKKCAAgoooIACCiiggAIKKLCgAIELIQ0zFTq0TCPEYeY+lTr9/f2pp6cnjY2NxWObN2+ONm2EOtXV1a8FO29W9ry5/gU3xCcUUEABBRRYJQErdlYJ3rdVQAEFFFBAAQUUUEABBRRQQAEFFFi6wKZNmyKcyQIawhtCnBs3bsQYOsPDw+nmzZvp4sWLaXR0NKpuWJZqnaqqqgh1GJuHCp3Jycl0+/btdO/evTQyMhIVO7Rp27FjRwRBvJeTAgoooIAChSZgsFNoe8TtUUABBRRQQAEFFFBAAQUUUEABBRRYUIDghXFymBlXh4Dm+vXribCG8Xd4npDn1q1b0YqNyp7W1taYuZ+FOn19fenKlSvp888/T9euXYuKH960oqIi1dXVpZqamtcqexbcIJ9QQAEFFFAgzwIGO3kG9+0UUEABBRRQQAEFFFBAAQUUUEABBd5fgLZqhC5NTU0x3717N01NTUWVTjY+DhU8tGajzRqhTldXV8zbt29P09PTqbu7O126dCmdOXMmffXVV9G6jVCIdba1tcU4PNu2bYtWb++/pb5SAQUUUECB3AgY7OTG1bUqoIACCiiggAIKKKCAAgoooIACCuRAgPZoVNU0NzenQ4cORVUOFTq0VaPyZv369RHePH/+PO7Tgu3kyZPp+PHj0WJtfHw8nTt3Lv3pT3+KW4IhXstyR48eTceOHYtgh/F7CIqcFFBAAQUUKDQBg51C2yNujwIKKKCAAgoooIACCiiggAIKKKDAggIEN1u2bEkNDQ3pxIkT6dmzZ9EyjSqdx48fRzs2xsih4oZbliEAohKHVmxDQ0Mxns7AwEBU9bx8+TJCov3796ePPvooHTlyJMbw4X2cFFBAAQUUKEQBg51C3CtukwIKKKCAAgoooIACCiiggAIKKKDAWwVqa2vT6dOnI+ChhRrj7BDWzMzMREUPY/Ds3bs3HThwIG4JejZu3BhVPLRzoy1bY2NjhDq0aqNah2Cns7MzVVZWvvW9fVIBBRRQQIHVFDDYWU1931sBBRRQQAEFFFBAAQUUUEABBRRQYEkCVNgwU7VDeENrNmbCHYKdp0+fRmjDcx0dHRHcVFdXR1UPb0TVDtU7BEAtLS2pvLw8xt/Zt29fYmb8HicFFFBAAQUKWcBgp5D3jtumgAIKKKCAAgoooIACCiiggAIKKPCaAKHOixcvEmPoEM5QhUNlDmFN1oqNx8rKyiLg4ZYKnWwiuPn444+jPRshEGPpUL3DuD3cOimggAIKKFDoAgY7hb6H3D4FFFBAAQUUUEABBRRQQAEFFFBAgVcChDqPHj2KcXK6u7sj3GEsHdqnUY2TzVT0UMnz5lg5VOhQqeOkgAIKKKBAsQoY7BTrnnO7FVBAAQUUUEABBRRQQAEFFFBAgTUoQJXOyMhIOnfuXPrlL38Z7ddou9ba2pp2794dlTvc1tfXRxUOAY+TAgoooIACpSRgsFNKe9PPooACCiiggAIKKKCAAgoooIACCpS4ABU7tFwbHBxMX3/9dbp+/XqEOM3Nza8FO4Q9tbW1qaqq6lUVz7Zt26JFG5U8tGBzUkABBRRQoBgFDHaKca+5zQoooIACCiiggAIKKKCAAgoooMAaFqC9WtZiLavgmZqaSr29vVHJQzs22rNRtUPbNcbfoYqHmcCnurraYGcN//vxoyuggALFLmCwU+x70O1XQAEFFFBAAQUUUEABBRRQQAEF1pDAxo0bE5U3VOgcO3Ys8feTJ0+iiodKnuHh4fibihzG3WlsbHytkofXEfgQ/BAAsS5uy8rKEm3bWJ+TAgoooIAChSzgL1Uh7x23TQEFFFBAAQUUUEABBRRQQAEFFFDgNQHCl4aGhnTy5MkIZ3p6elJ/f3/MfX19r+5PTk4m5unp6TQ0NJQuXrwYAQ6t2WjRRuVOVsXDbVNTUwQ+BELr1q177T39QwEFFFBAgUISMNgppL3htiiggAIKKKCAAgoooIACCiiggAIKvFWAihrmzZs3p5qamtTR0fEqzMkCHm7v378fwc7Dhw+jmoeqnvHx8WjXlr2WFm1ZmzZathH2EPBQ1UMAZMjz1l3hkwoooIACqyRgsLNK8L6tAgoooIACCiiggAIKKKCAAgoooMD7CxC6lJeXR5VNRUVFBDS0YstmqnVGRkbS4ODga8EPrdoePHiQBgYG4vbatWvRjo11MPYO7d1+8pOfpMOHD8f6bc32/vvIVyqggAIK5EbAYCc3rq5VAQUUUEABBRRQQAEFFFBAAQUUUCCHAuvXr0/MmzZtimBm7lu9fPkyAh4CHIIcWrR1d3enu3fvpjt37qR79+5FsDM2NhbBD8uzHsbaefHiRfr444/Tvn37Ysyduev1vgIKKKCAAoUgYLBTCHvBbVBAAQUUUEABBRRQQAEFFFBAAQUUWDEBxshhLB7G0tm2bVuMyUPLtfb29phv3ryZrly5ki5cuJBo0cZEoMN4PI8ePUpPnz6Nvwl8nBRQQAEFFCg0AYOdQtsjbo8CCiiggAIKKKCAAgoooIACCiigwJIFnj9/HoHMzMxMhDUENsxZa7aJiYkYd2dqaio9e/YsEdowz638KSsrS7Rko3qHcMhJAQUUUECBQhQw2CnEveI2KaCAAgoooIACCiiggAIKKKCAAgosWoCAhkCH1muMq8P4OYytw+3Q0FDcp+3aw4cPoyqHsIeAh7CHYIexehhfZ+fOnWnv3r1xf/PmzfHcojfCBRVQQAEFFMiTgMFOnqB9GwUUUEABBRRQQAEFFFBAAQUUUECB5QvMzs4mqnNomUaQQ0BDUDM5ORkVOVmQk4U7/H3//v2o3tmwYUNU4xDk0KatpaUlWrVVVVXF301NTenAgQPRus1gZ/n7yjUooIACCuRGwGAnN66uVQEFFFBAAQUUUEABBRRQQAEFFFAgBwKEOoQ5d+7cSWfOnEnXrl2Lqpws5GGcnKwNG7csz0SLtcbGxpgJcKjO4ba+vj7V1NTE81krNkIfg50c7DxXqYACCiiwIgIGOyvC6EoUUEABBRRQQAEFFFBAAQUUUEABBfIhkFXr9PX1pS+++CJ9+eWX0WqNih3asW3cuDFCmizI4baysjLCmyzMmRvsEOJQsbNly5Z8bL7voYACCiigwLIFDHaWTegKFFBAAQUUUEABBRRQQAEFFFBAAQXyJUCww1g5jKVD1c7du3ejQufZs2eJNm0EOfv374+Ztmq7du2KNmuEO1Tk0IaN22wm0Nm0aVO+Nt/3UUABBRRQYNkCBjvLJnQFCiiggAIKKKCAAgoooIACCiiggAL5Enj58mV68eJFVOfQko2ZQIfH507r16+P6h2CHEKd6urq14IdWq0R6LCckwIKKKCAAsUkYLBTTHvLbVVAAQUUUEABBRRQQAEFFFBAAQXWuABBDKEMlTaENtzSgo2wh4mgh3F3hoeH05UrV1Jzc3Nqa2tLLS0tMaYO7diYacFG4GMLtjX+D8qPr4ACChShgMFOEe40N1kBBRRQQAEFFFBAAQUUUEABBRRYqwKMobNt27bU2tqaTp06lbZu3RphzvT0dLRkI+R58uRJGh8fT4y7MzAwkHp6elJjY2MEOoyvw/36+vqo4qF1W9aWjVvWt3379giP1q1bt1aZ/dwKKKCAAgUsYLBTwDvHTVNAAQUUUEABBRRQQAEFFFBAAQUUeF2Aah2qbY4fPx5BDZU5o6OjMebO4OBgGhoaStzy+P3792M8Hsbk6e7ufq0VG+FQVVVVrIuwJ6vkobqno6Mj1dTUpA0bNiTDndf9/UsBBRRQYPUFDHZWfx+4BQoooIACCiiggAIKKKCAAgoooIACixQgbKEFGzOVN1TnjI2NRYhDoDM33CHkefDgQVT0PHr0KJZ9/PhxLP/8+fMYl4fqnCzUIeA5fPhwVOzwOG3aeD8nBRRQQAEFCknAYKeQ9obbooACCiiggAIKKKCAAgoooIACCiiwaAGqaajgqa6ujvZsBD379++PAIfAh5kxdwh3RkZGXgt9+vv7U29vbwRCLJNV9FD9s2fPnhiPh7ZvBjuL3h0uqIACCiiQJwGDnTxB+zYKKKCAAgoooIACCiiggAIKKKCAAisvMLeCh9Zq2fTy5cuoyKENG1U8hDiMocNE1Q5t2mZnZxOVPCzD8kyMvTMxMZGePXsWz8eD/o8CCiiggAIFJLC+gLbFTVFAAQUUUEABBRRQQAEFFFBAAQUUUGBFBAhqaLeWVe3Qro3KHQKdrEXbzMxMBDpZqLMib+xKFFBAAQUUyLGAFTs5Bnb1CiiggAIKKKCAAgoooIACCiiggAK5E3jx4kV6+vRpIqShEiebp6enoxqHMGdgYCDmvr6+RAs25snJyUQrt8rKyrR169Zo5cbtgQMHUm1tbbR4W7/ea6Jzt+dcswIKKKDA+woY7LyvnK9TQAEFFFBAAQUUUEABBRRQQAEFFFh1AUIdqnGGh4cjsCG8YSbMoQUbzxHyMGehD7eEOuXl5dF6bffu3Smbu7q60r59+9L27dsTY+w4KaCAAgooUGgC/joV2h5xexRQQAEFFFBAAQUUUEABBRRQQAEFFhTIKnSouKGlGoEO7dUIcajEyapyCHZ4jkCHgGbz5s1RlcM4PE1NTYnburq61Nzc/CrUaWtri+eyip0FN8InFFBAAQUUWEUBg51VxPetFVBAAQUUUEABBRRQQAEFFFBAAQWWJpBV6Fy6dCn9+te/TpcvX462ag8fPnytIoexdWjPtmnTplRdXZ127tz5WoBDoFNfXx8Bz7Zt26IdG63YysrK0pYtW5a2US6tgAIKKKBAHgUMdvKI7VspoIACCiiggAIKKKCAAgoooIACCixP4Pnz54kQp7e3N509ezZmWqu9fPkyAhnaqxHQUHXDLaFOQ0NDamlpiWCHqhzarjU2NqYdO3ZEkLO8LfLVCiiggAIK5FfAYCe/3r6bAgoooIACCiiggAIKKKCAAgoooMAyBGZnZxNVO4Q5jx49ilvasxHoEODM11qtpqYmKnMIerKZyhyqeZwUUEABBRQoNgGDnWLbY26vAgoooIACCiiggAIKKKCAAgoosIYF1q1bl9avXx9BDu3Vurq6IqwhvOHv1tbW11qu0W6toqIixthZw2x+dAUUUECBEhIw2CmhnelHUUABBRRQQAEFFFBAAQUUUEABBUpdYMOGDRHk7Nq1K333u99NJ0+eTLRXy1qrVVZWxvPZuDmMl7Nxo6fASv3fhZ9PAQUUWEsC/qqtpb3tZ1VAAQUUUEABBRRQQAEFFFBAAQWKXICQZvv27VGZQ+UOM8FOXV1djJdDRc+TJ0+iXRut2iYmJhKt2ph4LTMt2DZv3hzLG/oU+T8IN18BBRRYgwIGO2twp/uRFVBAAQUUUEABBRRQQAEFFFBAgWIVIJShtRqVOLRfI8hh3Bwe5z5hzvDwcBodHU2Tk5Pp4cOHaXp6Oj4ugRCvraqqitcyJg+P8TonBRRQQAEFikXAYKdY9pTbqYACCiiggAIKKKCAAgoooIACCigQFTqEOsyENM+ePYvghiDn/v37aWhoKPX19cV9qnWyYIfwhvZsWbDD2DuMx8O4PLW1tfF4WVmZbdv8N6aAAgooUPACBjsFv4vcQAUUUEABBRRQQAEFFFBAAQUUUECBhQSoxrl37166fPlyOnPmTLp582YaGRmJQIfQ5/nz5/O2YqNqh1DnwIED6eOPP0779++Pv6ngcVJAAQUUUKCQBQx2CnnvuG0KKKCAAgoooIACCiiggAIKKKCAAvMKENo8fvw4Qh0CnS+++CLmu3fvRqhDoEN7tmxcnZcvX0bAw+O8lueqq6ujwocxeWjhduLEiajiYfydDRs2zPu+PqiAAgoooMBqCxjsrPYe8P0VUEABBRRQQAEFFFBAAQUUUEABBZYsQKjT09OTvvzyy/TLX/4ynT9/Pj148CDCntnZ2URbtR07dsQYOozBQ7BDeENrNlq0PX36NI2NjaWrV6++auFGe7fy8vJozcatkwIKKKCAAoUoYLBTiHvFbVJAAQUUUEABBRRQQAEFFFBAAQUUmFeAgIaZUObChQvp888/j1Cnu7s7EeA0NDQkxs+pq6uLgKaysjIez4IdQh3G4mGmZdvU1FS6detWjN3T1tYW4/AcOXIkAp55N8AHFVBAAQUUWGUBg51V3gG+vQIKKKCAAgoooIACCiiggAIKKKDA4gUIaGilNjAwkH73u9+l3//+9xHSEOrs2rUrHT58OH37299Oe/fujYodHs/aqtGGjYqd0dHRdO3atfTZZ59Fxc7w8HBi/vTTT9O6detSU1NTamxsXPxGuaQCCiiggAJ5FDDYySO2b6WAAgoooIACCiiggAIKKKCAAgoosDwBwhlaqhHEXL9+PVGpQ+u1lpaWGCOHUIe5o6Mjqm8YS2fuNDMzE63YCG4IcXj+3LlzEfbcuHEjAh1auhEeEQitX79+7su9r4ACCiigwKoLGOys+i5wAxRQQAEFFFBAAQUUUEABBRRQQAEFFivA2DhU3GRt1Ah1qqqqUldXV/qHf/iH9OGHH0Yrtm3btr2q1Jm7boIclqeih2oeWrUR5ExOTkZbNu7Trm16ejqeN9iZq+d9BRRQQIFCEDDYKYS94DYooIACCiiggAIKKKCAAgoooIACCixKgGCH8IUxcghfCGqovuns7EwHDx6MWyptqMaZbyKo2bJlS4zBU1FREYHO7t27U09PT1QBMebO+Ph4PM66mZ0UUEABBRQoJAFrSQtpb7gtCiiggAIKKKCAAgoooIACCiiggAJvFciCHcId7lN1097envbs2ZMIat4W6sxdcRbw7NixI7W1tUUrt/Ly8lgn687WP/c13ldAAQUUUKAQBAx2CmEvuA0KKKCAAgoooIACCiiggAIKKKCAAosSePHiRXr8+HHM3N+8eXMinGGmEmehSp03V85yhEBlZWXRmo2WbFTnZOt/8uRJjN3z5uv8WwEFFFBAgdUWMNhZ7T3g+yuggAIKKKCAAgoooIACCiiggAIKrKrAy5cvV/X9fXMFFFBAAQWWImCwsxQtl1VAAQUUUEABBRRQQAEFFFBAAQUUWFUBqmxomUYLto0bN0brtLGxscQ8MzMTVTaLCWpY5vnz54nKnImJiRhT59mzZ7FO1s/MezkpoIACCihQaAIGO4W2R9weBRRQQAEFFFBAAQUUUEABBRRQQIEFBWi9Vltbm2pqaqIN26NHj9Ldu3fTnTt3Ipyhldpigh2WIwgiEOru7k69vb3R3o31s+5s/QtuiE8ooIACCiiwSgIbV+l9fVsFFFBAAQUUUEABBRRQQAEFFFBAAQWWLJAFL3V1dVG1Q9XN0NBQunnzZrp8+XLavn17qq+vTxUVFVF9s37969c1E+hQmTM+Pp76+/vTpUuX0r179+JvluX11dXViTF3qAhyUkABBRRQoNAE/HUqtD3i9iiggAIKKKCAAgoooIACCiiggAIKLCiQVewQ3hC+0C5tcnIy3bhxI/3617+OtmqnT59OHR0dEdKw/NwpC3WuX7+efv/736fPP/88gh0CH8IgAqOqqipbsc1F874CCiigQEEJGOwU1O5wYxRQQAEFFFBAAQUUUEABBRRQQAEF3iZAFc22bdtSY2Nj6urqimodKm4GBwfTuXPnor3a06dPoxpnx44dUdWTjZVDePPw4cM0MjKSrl69mv74xz/G7YMHD2KdrO/gwYNRsbNp06a3bYbPKaCAAgoosGoCBjurRu8bK6CAAgoooIACCiiggAIKKKCAAgosVWDdunXRIm3nzp3pb//2b2M8HcbZIdxhnJypqal069atV+PwUNVTVlYWbzM9PR0VPaOjo4n5/v37sTzt3AiKPvnkk/S9730vWrktdbtcXgEFFFBAgXwJGOzkS9r3UUABBRRQQAEFFFBAAQUUUEABBRRYtgDBDjPVOB988EF6/PhxVO2wYipvqMaheocWbIQ6VPfMDXao2KF1G2EOy9B+jbZuJ06cSKdOnUoHDhyIx5a9oa5AAQUUUECBHAkY7OQI1tUqoIACCiiggAIKKKCAAgoooIACCuROoLy8PLW0tCTaq83OzkbFzZkzZ9KdO3eiCmdmZiaNjY3F/awVG2FONm/ZsiXV1NSkffv2pY8//jh961vfetWG7c1xeXL3KVyzAgoooIACSxcw2Fm6ma9QQAEFFFBAAQUUUEABBRRQQAEFFFglAYKcZ8+eJcbRYSbg6ezsjJZsBDLNzc1RtUNLNpYjyCH4YSLgYYwexs+h4qepqSkqdAh2GF+Hdmysz0kBBRRQQIFCFjDYKeS947YpoIACCiiggAIKKKCAAgoooIACCrwmQFhDJU42P3nyJJ5vb2+P6hvG2+nv74/xc2i5Rus1lqF9G6ENrdeqqqqi/RoVPw0NDTEeD49TxeOkgAIKKKBAoQsY7BT6HnL7FFBAAQUUUEABBRRQQAEFFFBAAQVeCVClQ6hDy7UbN24kghyqb3bv3p2OHz8e4+owzg7j7UxMTMTzWfizdevWtH379gh2aMPG2Do8RujjpIACCiigQLEIGOwUy55yOxVQQAEFFFBAAQUUUEABBRRQQAEFov0aoc3169fT//zP/6ShoaFUV1eXPvzww0TVDu3UmKurq6MVG63bmJnmtmKjbRsVOoY6/qNSQAEFFCg2AYOdYttjbq8CCiiggAIKKKCAAgoooIACCiiwhgUIYhgnZ2ZmJnV3d6ebN28mqm+Yab22fv36tG3btqjMWcNMfnQFFFBAgRIWWF/Cn82PpoACCiiggAIKKKCAAgoooIACCihQYgJlZWWvqnK4z5g7BDq0Z2M8HQKf2dnZEvvUfhwFFFBAAQX+n4DBzv+z8J4CCiiggAIKKKCAAgoooIACCiigQIEL0EKNNmu0W2toaEgVFRXp+fPn6f79++nWrVsx9s7U1FR6+fJlgX8SN08BBRRQQIH3EzDYeT83X6WAAgoooIACCiiggAIKKKCAAgoosAoCjJNDq7X6+vrU2dkZ4+pQuTM8PJx+//vfx8x9xtUx3FmFHeRbKqCAAgrkXMAxdnJO7BsooIACCiiggAIKKKCAAgoooIACCqyUAGPsEO5UVVWlrq6uqNSh/RpVOlevXo3xdwh6aM1WWVmZysvL4zFew8zr3zZt2rQpXsMty75r+bety+cUUEABBRTIhYDBTi5UXacCCiiggAIKKKCAAgoooIACCiigQE4EqMJhXB0Cm4MHD8aYOgQ7N27cSCMjI+kPf/hD6uvrS3v27ImKnp07d0a7NpbfsmVLhDxvC2to7dba2hrB0caNGw12crIXXakCCiigwHIEDHaWo+drFVBAAQUUUEABBRRQQAEFFFBAAQXyKsB4Og8fPoyKHMbVGR8fj6CHsGdiYiI9fvw4Ap6enp7U29sbY/EQ1mzdujWCnXdV7RDqMI4Py69fvz7mvH5A30wBBRRQQIF3CBjsvAPIpxVQQAEFFFBAAQUUUEABBRRQQAEFCkeA6pzR0dF06dKl9J//+Z/p66+/jnCHsIdQh7F1pqen08DAQJqcnEy0ZaPyZrGt2I4dO5aam5sTlT60Y3NSQAEFFFCg0AQMdgptj7g9CiiggAIKKKCAAgoooIACCiiggAILCszOzqanT59GaEPLtf7+/liW6ppt27a99ronT54k5qVMTU1NEQwRENH2zUkBBRRQQIFCEzDYKbQ94vYooIACCiiggAIKKKCAAgoooIACCiwoQOUNVThVVVWppaUlTU1NrWgAQ7BDQPSulm0LbqBPKKCAAgookGMBg50cA79r9dmVH/MN2kdvWEqIubKEMmOWpQSYPq8M+MetBxnvEvZ5BRRQQAEFFFCgtAQ8fiyt/emnUUABBRRYugBt1bZv354YC+fUqVPRMi37fVz62r75it27d6f6+vo4BzPf+ZpvvsJHFFBAAQUUyK+AwU5+vV97Nw465h54zD1Y4HH6wTLI3+DgYGIwQEqAKysrU11dXfR6ra6ujoCHAxonBRRQQAEFFFBAgdIX8Pix9Pexn1ABBRRQ4N0CXPS6Y8eOdODAgQhguCh2JaetW7fGermolgtqnRRQQAEFFCg0AROBPO4RghkqbxjMb2xsLG6pxuEqE64G4aCEiUCHIKe7uztdvXo13bt377Vgh6tGdu3aldra2lJ7e3sEPRzUeLCRx53pWymggAIKKKCAAnkQ8PgxD8i+hQIKKKBA0Qlw/oOZdmxc/OqkgAIKKKDAWhMw2MnjHifUIbC5detW+uKLL9LNmzfj787OzvTzn//8VbAzOjqa/vjHP6YzZ86k8+fPJwYCZFBArtCkOoc+r/SRPXr0aPrRj34Ut1TvGOzkcWf6VgoooIACCiigQB4EPH7MA7JvoYACCiiggAIKKKCAAgoUmYDBTh52GFdaMl7O0NBQunDhQjp37lyENgQ7hDiPHj1KExMT0WqN/3jv7+9PZ8+eTZ999lm6ceNGevDgQVq/fn3KWrUR4FChw+uo3uEKlUOHDsVtHj6Ob6GAAgoooIACCiiQYwGPH3MM7OoVUEABBRRQQAEFFFBAgSIWMNjJw84j1CG4uX79evrv//7vqNYZHh5OU1NT6fnz51GJQzVOdkXmnTt3IgAi1GEZQp3NmzdHRQ7hzuzsbARFVPL87ne/i8CnoaEhQp48fBzfQgEFFFBAAQUUUCDHAh4/5hjY1SuggAIKKKCAAgoooIACRSxgsJOHnccgfoQwjJdDazVumWip1tLSkvbs2RP3s+UIdlh+fHw8Ah2qchhPh/ZrTDx++/btGKPn2rVrEejQ4o1giEoegiAnBRRQQAEFFFBAgeIVyI4LPX4s3n3oliuggAIKKKCAAgoooIACuRIw2MmV7Jz1UnVDAHPlypVoq8ZThDqMrfPd7343nT59OjU2NkZrNQIbgh3arFGlw9g5jKXz4x//OO3duzeqdS5dupT+/d//PV2+fDmNjY2lwcHBGKtncnIyVVZWpi1btsx5d+8qoIACCiiggAIKFJuAx4/FtsfcXgUUUEABBRRQQAEFFFAgfwIGO3mwnp6eTt3d3enevXtRZVNeXp46OjrSyZMn03e+85105MiRqMahSqe3tzf19PQkXrN169ao1OH5jz/+OB08eDDG4WFMnS+//DKWZYwe2rwR8BDssG6DnTzsVN9CAQUUUEABBRTIoYDHjznEddUKKKCAAgoooIACCiigQJEL2LMrDzvw6dOnUVGTtUurra1N3/72t9P3v//9dPjw4dTU1BSBzJMnT9LAwEDM3Kf65tChQ7EMryGwIbjZsWNHBD6tra3xN+P0EOowc99JAQUUUEABBRRQoLgFPH4s7v3n1iuggAIKKKCAAgoooIACuRSwYieXun9dN4Pfzg1etm/fnrq6uqICh1CHv2dnZ6NKZ2RkJEIgxsvJ2rXRsq2ioiJt3Ph/dxeVPDU1NdGmjXZthDm0buPKToOdPOxQ30IBBRRQQAEFFMixgMePOQZ29QoooIACCiiggAIKKKBAEQtYsZOHnffixYvEALhU4XCfyhsqcLIqHEId/uOdcIbWarRV4ypNqnOam5tTS0tL3M82df369TH+DqEO93k9yxMGcd9JAQUUUEABBRRQoLgFPH4s7v3n1iuggAIKKKCAAgoooIACuRQw2Mml7l/X/fLly8RM6MLtm8EMoQ5hDqEOlT0ENFTnUKVTV1cX1TmEONnEeqjMYZ4b5Kxbty5bxFsFFFBAAQUUUECBIhbw+LGId56broACCiiggAIKKKCAAgrkWMBgJ8fArJ4gh6CGmftcgUl4w5xdjdnX15d6e3ujnVoW6jCWDuPsULmzYcOGV1tKoDO3tRvPsUxZWdlry716gXcUUEABBRRQQAEFikrA48ei2l1urAIKKKCAAgoooIACCiiQVwHH2MkDN8EL4+IwZs6DBw+iJVt/f3/q6emJd5+amkpXrlxJ169fT9ynVVt9fX1qbGyM8Xc2bdoUyxHoEAZR3TM0NPRqLB6CINbNWD3cd1JAAQUUUEABBRQobgGPH4t7/7n1CiiggAIKKKCAAgoooEAuBUwBcqn713XTRo3qG2YCmYmJiXThwoUIe7LqmzNnzqTz58+n8fHxqL5pbW39xtg6hDojIyOpu7s73blzJxEOMW4PwU9VVVXMWQiUh4/lWyiggAIKKKCAAgrkSMDjxxzBuloFFFBAAQUUUEABBRRQoAQEDHbysBNpk9bS0hIzoQxt1K5evRrj4xDyPHr0KH311Vfp3r170Yqtubk5tbe3x0wlzuPHj6PShyDn9u3b6ezZs1Htw+Osu6amJmbG5LFiJw871LdQQAEFFFBAAQVyLODxY46BXb0CCiigQEkIMGYx51SYHz58GOdUOFdC23vamlIBy8USzHRHyebsby6OZRmWdVJAAQUUUKCYBAx28rC3aJHW1dWVBgYGolKHqp0bN26kwcHBCHSo2qESh4MQDj4YV2ffvn0x81rat33++efpyy+/TF9//XW6efNmVOtwQEIItHv37lRXVxft2Ax28rBDfQsFFFBAAQUUUCDHAh4/5hjY1SuggAIKlIQAgQ4XyXIRLOdKuM9FsdPT0xHmcLFsdXV1qq2tjfMmnDuh9T23zHQ/oXW+wU5J/HPwQyiggAJrSsBgJw+7mwMJwpf9+/dHWEPFDuPk0Hbt5cuXsQUcRHAw0dDQkPbu3RszVT5crUnowwEKVT20axseHo7KHJ4/evRo+uCDD+KAhCtOnBRQQAEFFFBAAQWKX8Djx+Lfh34CBRRQQIHcCXBRLO3quYCWriacK1ko2Mm6nGRhThbscEvLfC6u5XwMF89mlTz8zeM8tm7duphz92mWvmbOJ3GOyGl5AutuPUjrxifSuuWtZtVePf6XbR/7y7/9lw//7xjeq7YhvrECqyDAdyDfhWt5MtjJw94vKytLTU1N6dChQ+lv/uZv4kqQc+fOxVUkHIxwkMDBQ2NjYzpx4kT6zne+E8EOBx88/vTp0wiCRkdHY0wdqnK44oSqnu9///vp448/jmAnDx/Ft1BAAQUUUEABBRTIg4DHj3lA9i0UUEABBYpWgFCHcyRXrlxJv/rVrxLnWOiCQgUPYxHTGYXzLbRqo3qHC2TnBjfcZ84CHM6xZIEPARAX5x44cCAuvuUcDOdtCmm6e/du+td//df0i1/8opA2q+i2pf15Rfr+TEvakyqKbtvZYP4d/O//91m6u3GqKLffjVZgOQKEOvx/YC1PBjt52PscBNBOo7W1NX3rW99K9HBlPJyenp444OAAgefb2toi2Dly5EjauXNnVOuwefR75WCD4IfKHmaComPHjqWTJ0+mjo6OV8vm4eP4FgoooIACCiiggAI5FvD4McfArl4BBRRQoKgFuAD2/v370Xrt2rVr6datW9HZhHMrhDJUvnIuZXZ2NsIdgiBmxt/hZCD3WUfWPYWWbFmwwy2dUbjYloqe7DxMIYFZsbMye2NveUOqqP0gjf/lthinm4+H0+9HLyZunRRQYO0JGOzkcZ9zoHD48OEYF+ejjz6KsXP4MSbYyUqDswMHSn6ziRCINm4cmLAszxES0YqNgId2bRywOCmggAIKKKCAAgqUloDHj6W1P/00CiiggAIrI0BVDlU4zIQ0XBDBuRMufD19+nTas2dPnCuhcodW+FT30OaeMCi75XHWQ0UPIQ9t83t7e6OSh8c4f8MFuFycy/qdSk9g8OlE+v//EoxUbNhSlB9u6sVM4jM4KaDA2hTwlykP+50DhKmpqTjYYEwd/gOdsXS4coQyYa7+4CoQAhruv1niyxUnjLtDFQ9tOViW13PQMt/yefhIvoUCCiiggAIKKKBADgU8fswhrqtWQAEFFCh6AQIbzrMwc59zJXQ5oX3at7/97XTw4MF5gx1CnSzYefDgQYQ5hDtZRU92y7kafotp55aNjVz0aH6Abwg8/EswYrXLN1h8QAEFikTAYCcPO4oDjRs3bsTBA/1dCWR27doVVTqEPIyjwxUgC4U0VOpwtQkHK1TmsCwHLQstn4eP5FsooIACCiiggAIK5FDA48cc4rpqBRRQQIGiFyBs4WJZZu5zQWxnZ2dU2XR1daX29vY4f8JzBD6ENFlowy1hDm3ZqNKZW8WTBT+0c6NbCudg3rz4tujx/AAKKKCAAiUhYLCTh91ICW93d3e6efNmlAAT5HCQQAUOrdc4WGAMHWZCHAbwI7zJ2quxPLOTAgoooIACCiigwNoQ8PhxbexnP6UCCiigwPsJcL6EC16Zswtg6W7C+DhZi/u3rZlAiGocKnNo05aFO1k1T3V1dXRK4VwMF9U6KaCAAgooUGgCBjt52CNcDULf1ytXrkTlDleEEOJwoMCVI83NzRH00LuVwIfHqOTJgp08bKJvoYACCiiggAIKKFBAAh4/FtDOcFMUUEABBQpOgAti6+rqYiZ8oQKHLifMi2mdRhUO51y4uJbxczg/wzmZrKqHdRIQOaZxwe16N0gBBRRQ4K8CBjt5+qfAQQNt2OjhymB8lAFzIFJbWxuVOwQ6WbBD0MMBCuFOVsXDLVei8BoDnzztNN9GAQUUUEABBRRYRQGPH1cR37dWQAEFFFhVAcKZbHwbfg+Z57ajJ3jhvAkVOpwvGRsbS+Pj43HOhZCHipzsdfN9kOw51knHlEKbqD46fvx4oW2W26OAAgoUjQDfoXyXlvJksJOHvcsVHk1NTVGNMzQ0FH1cCXgIdyj5pfR3YGAgff3113FAwj86DlB4TRb2EPzwN0EQBy1OCiiggAJKKw0rAABAAElEQVQKKKCAAqUr4PFj6e5bP5kCCiigwLsFCHUIaLjl4laqaua2rM8qdhoaGqK9Pe3ve3p60p07d9LExERcWMvyBDjFOLX/ZYygf/mXf0k//elPi3Hz3WYFFFBg1QU4v853aSlPBjt52LsEMQQ0DMzHwQgVOfRtpSUbj2UzIU9fX18ceDDwH1eezK3kaWlpiTZtlAizzmzmP/yp5mHdTgoooIACCiiggALFL+DxY/HvQz+BAgoooMD7CxDqcGEs50k4d0IFD23TOP9BqJOFPIQ+nGMZHBxMDx8+THfv3k1Xr16N1mpcHFtRUfHWyp3338LcvtKKndz6unYFFFCgFARMAvKwFzn46OzsjIH3jh07FlePcGDC4Hz9/f3fmLm6hAMSAh+WYWwe1lFZWRkHJzt37nwt8OEghnF5CIOK9WqUPOwG30IBBRRQQAEFFCgaAY8fi2ZXuaEKKKCAAjkQ4JzI9evX07lz59JXX30V51G4yDVrv8aFsNynE0pXV1eMrXPmzJkIdn7729/G35988klcEEv447mSHOwkV6mAAgoosKoCBjt54Kf3KzMHIUwM5sfVJ/SAzYIdKnWy+4Q5c8MdAh6uPmEZ+r9mg/plbdoOHDiQTp06Fe/BVSss46SAAgoooIACCihQvAIePxbvvnPLFVBAAQWWL0BgwzkTKnDOnj0b7esZh5j29IQ6tGDjlgoe2rWx/MzMTJqamkrnz5+PIIfOJvxN9QsXwmbVPnQ7cezi5e8j16CAAgoosLoCBjur4M8BBAcYHJBwNWZra+urdmwEPoQ6hDuUHRP2ZKEP4c7w8HAc0LDMrVu34uqTkydPJg5wOFihzJgTAU4KKKCAAgoooIACpSPg8WPp7Es/iQIKKKDAuwWosCGAYeY+wc34+Hianp6O8yKcD6ElG7+PtGnjccYy5kLae/fuxcW0nFehmoeLYTs6OqJlG1U+dEPhglireN69H1xCAQUUUKBwBQx2VmHfzD1AoX96NnEwMjs7G1eUEOIw+B8hDY9xkMLVKlyJwhUnzNlEmMMBDAc6LOukgAIKKKCAAgooUFoCHj+W1v700yiggAIKvF2Ai2FpOU8ww/kOqnOyqhwqc7LqnOw+gQ7nSzgnwnJcNEsQNDAwEBfNcn6FNvZU+nBRLBfZEgwxc94lu5/9nY3hY0eUt+8nn1VAAQUUWD0Bg53Vs//GO3MA8uzZs6jeYQweqnIIcOgtS7DDAYvBzTfYfEABBRRQQAEFFFizAh4/rtld7wdXQAEFSlqAqppDhw5FuHP8+PGo0qECh3lkZCRus7+55RwKbeyzcyacW+GcCiEPzzNWD63YuLiWma4nVO/MnbNxe7KqHpYz2Cnpf2Z+OAUUUKCoBQx28rj7qMhhzsbY4QqSuTPhDSEOlTlU7GQzV5jQgo3nuFqTK0u4eoWDEm53794dByVcUWIpcR53qG+lgAIKKKCAAgrkWMDjxxwDu3oFFFBAgYIUoHKGoKWmpiYxvjAXvc4Nct68z3mUuRfFzq3uefToUZxn4WJZflc5d8KYO7THz4KduaEOj+3atSvt27cvtoF2cAY8BfnPxI1SQAEF1rSAwU4ed38W6nBAQlAzN7jhPmPqcOUJV5VwpUkW+mT3eT0HFBx87Ny5MzU1NcXMVSwc6HA1Cc87KaCAAgoooIACCpSGgMePpbEf/RQKKKCAAu8nQKBCyMMtF7fSSo2AZm5ww33CG6p2CHjmhj5zq3tGR0djuayah3MuPP9mGzb+PnbsWPqnf/qnOM/CxbWOZfx++89XKaCAAgrkTsAUIHe2r9bMwQK9XekLy4EEBw6EOMxU4xDqcMvjLEdFT3ZgQUUOQQ63XFGSlQtnwQ63XEnCwQ0HGl5F8ordOwoooIACCiigQNEKePxYtLvODVdAAQUUWEEBupJs2LAhZs6LLDQR1hDucE4lC3bmhjo8xvkYLqSlWwq/s9n4PFkwlI1dzN+859///d9HgESg5KSAAgoooEChCRjs5GGPcGBBP9fz58/H3NvbGxU5WSUOBxTMDPRHMJNV5BDaZAEO1TmUA1dXV6eKiooIejioYaZShytIOPCwFVsedqhvoYACCiiggAIK5FjA48ccA7t6BRRQQIGSEuB8COdFaLPGBbGtra2vBTdZiJO1vyfEeTP4ycIfqn6yi2apnHVSQAEFFFCgEAUMdvKwV7gapKenJ124cCH96U9/ivvZgH4EMVz9sWPHjgh0qLwhzGlubo42a1mwwy2BD6EO1TxOCiiggAIKKKCAAqUr4PFj6e5bP5kCCiigwMoLEMQwE+wQ8Mw3EdJwUS1VOwQ7WWXP3Fuqepjb29tjfB07o8wn6WMKKKCAAoUgYLCTh71AazWuCmGmPJhQhwMKDjoYE4cw5/jx4+nIkSPp4MGDqaWlJQIcDkayqhxuOaDgIMVJAQUUUEABBRRQoLQFPH4s7f3rp1NAAQUUyL8AF9ZyXoULa+l8Ul9f/42xegh+6K7C+Rja3nPrWMb531e+owIKKKDAuwUMdt5ttOwlsqtGOICg2oZwhv9Yf3PKBsfNBgHkdTw2d+ZAhIMKbpmdFFBAAQUUUEABBUpPwOPH0tunfiIFFFBAgdUXeNd4PZx/oU0+E7/FnntZ/X3mFiiggAIKzC9gsDO/y4o+SqDD+DhZOzXKfqempqJ6h4BneHg4/fnPf07Xrl1LlZWVqaamJq4caWxsjNfwumymuod2bFm4s6Ib6soUUEABBRRQQAEFCkLA48eC2A1uhAIKKKDAGhMgyCH8ySYvqM0kvFVAAQUUKDQBg5087BFKfCnhPXr0aBwgMIgfA+LSmo0y32ymr2t/f3+ENgz2x5g6TU1Nr0Idgh7m6urqKAdmbB5atG3fvj0GB+S+V5PkYYf6FgoooIACCiigQI4FPH7MMbCrV0ABBRRQYAEBw5wFYHz4lQDt+hinidssDKRDDzMX5zBzQTZVX04KKKBArgQMdnIlO2e9VNgcOHAgNTc3pw8//DAG6pucnIyB+oaGhtLg4GCae0tFz9jYWMy9vb2vxtkhyGGmHyy9YAl5CH46OjpifB6qemjz5kHIHHzvKqCAAgoooIACRSjg8WMR7jQ3WQEFFFBAAQXWhAChDp13uDibc3DZmE1062HmvB3HcgQ8TgoooECuBAx2ciU7Z71Zas+XO9OzZ8/So0ePIrjJAp254Q6VO/xIzK3ooXUbLdt4HeEN66ItG8EO1T+EPLRwo2TYKwLm4HtXAQUUUEABBRQoQgGPH4twp7nJCiiggAIKKLAmBBgbmwuyuRibLjych2NoBbrvEOpwy7xt27YId7LjOoKe7D63VPVwHs8LtNfEPxs/pAIrLmCws+Kk714hX9p8uRPQ8MVPmzZ+CGZmZuKW8IaKntHR0ajkGRgYSMz37t1LN27ciIofAiEqe3p6ehKD+504cSK1t7e/Kvd891a4hAIKKKCAAgoooECxCHj8WCx7yu1UQAEFFFBAgVIXIJRh+ISRkZEId7hAm3Gzp6enE6EPQQ/DJhDyZFU8c2/pwsPfnBPMAp5SN/PzKaDAygsY7Ky86TvXyBc8M8EOAU82zc7OpufPn0dVDhU7WUknoQ9XAvAf9ExU/GRVP/xNMEQYxGsJeZwUUEABBRRQQAEFSkvA48fS2p9+GgUUUEABBRQoXgGGSWhpaYlzc9nY11n3HS7C5sJtuvBw7o5zely8TQhEe7assoeuO6xj3759EfJwrGflTvH+m3DLFVgNAYOd1VBf4D0JZvji58u+u7s73b17N925cyfdvn07ZoIeApyFJn8AFpLxcQUUUEABBRRQoDQFPH4szf3qp1JAAQUUUECBwhXgIu3Ozs7EWNePHz9+1YWH+5y3y8bO5pahFQh2uKUbD7eEPVzcfeTIkfTP//zPEfhQuZNd0F24n9wtU0CBQhIw2Mnj3qCahjlL7Pki50s/m/lyZ7wcxtLp6+uLih3CHGa+/Al96L9Jqs+PCIOzMR86dCjSfXp1kvA7KaCAAgoooIACCpSGgMePpbEf/RQKKKCAAgooUDoCnH9jrq6ufu1DccEN1Tqc36OChyEWuHib+9nf3NKVh3N8hDt23nmN0D8UUGAJAgY7S8Ba7qJ8WfMlzxf84ODgq+AmC3EYN4cWbCT5WeKfhT6EQLRuI9ThioDdu3fH3NbWFmWb+/fvj/6dBD9OCiiggAIKKKCAAqUh4PFjaexHP4UCCiiggAIKlL4AFTdZ5Q3t2hobGyPoIexh7J3sNhtbm9ZsHR0dcb7PLjyl/+/DT6jASguYAqy06DzrI5ShEodEnmSeihwqcJgJdbJgh+cIdQh/6NHJjwAVOQy2xi1XAhDq0IOTYIdQh1t+KOjRydUCTgoooIACCiiggALFL+DxY/HvQz+BAgoooIACCqwtAcIZLrhm5rzeQlM2bjYX8HC+j0DIYGchLR9XQIGFBAx2FpJZwccJdc6fPx/zV199lXp6etL09PSrFmxZVQ7pPaEOgU5DQ8M3AhxCHSp2CHH44s9mfiyo5nFSQAEFFFBAAQUUKA0Bjx9LYz/6KRRQQAEFFFBAgTcFCHIYYoFghxCIUMdg500l/1ZAgXcJGOy8S2gFnifE6e7uThcuXEiff/553KePJl/khDjMtbW1r8bNIbxpbm5Ora2tr6pyqMypr6+PZQxxVmCnuAoFFFBAAQUUUKCABTx+LOCd46YpoIACCiiggALLEGB8bMfIXgagL1VAgRAw2MnDPwSqcBgUjbF16KdJqEMSTzrf1NQUAU7WWo32arRWo/0avTazqhyWzfp05mGTfQsFFFBAAQUUUECBVRTw+HEV8X1rBRRQQAEFFFBAAQUUUKDABQx28rCDSOEZ/6aqqiq1t7enurq6CHWo0mG8nF27dr0aM4dgh8dpr0Y5ppMCCiiggAIKKKDA2hPw+HHt7XM/sQIKKKCAAgoooIACCiiwWAGTg8VKLWM5QhqqcD744IPU0dERrdcIcxhHh/Fytm/f/qoNGxU6hEC0aXNSQAEFFFBAAQUUWJsCHj+uzf3up1ZAAQUUUEABBRRQQAEFFiNgsLMYpWUuQ1hDJQ6t1WjBRuUOwU51dXVivBwGS3v27FnM9FOnZVvWro2qHZbJZgIf+3Auc4f4cgUUUEABBRRQoMAFPH4s8B3k5imggAIKKKCAAm8IPH78OI2NjcVwDE+ePInzfJzzW2jiQu+dO3fG+ULO9XHO0EkBBRRYrIDBzmKllrEcX9R79+5NT58+jS9pQpry8vJXoQ5f/OPj42liYiJNTk6mR48exbKEOFT0MGdj7jDWjsHOMnaGL1VAAQUUUEABBYpAwOPHIthJbqICCiiggAIKKPBXAQKcBw8epC+//DJdv349DQ0NxTm+Fy9exMXb80Ht27cv/fCHP0z79++Pc4R275lPyccUUGAhAYOdhWRW8HFaq9XU1LxaIwHPw4cP08DAQLp//34aHR2NmVR/brBDtQ5VPlmwwzpo38YYPFT7EPKwjEHPK1rvKKCAAgoooIACJSHg8WNJ7EY/hAIKKKCAAgqsAYHsPN/du3fT2bNn07Vr1xIXcT9//jw+/UKVOJzfm5mZiU4+a4DJj6iAAissYLCzwqDvWh0JPq3Wbt68mS5duhRJ/p07d6JahzZstGTji59WbAQ2c1ux1dXVReXP4cOH06lTp1J7e3sEP/yHv5MCCiiggAIKKKBAaQp4/Fia+9VPpYACCiiggAKlIUDnHc7tff3113Gejwu4qcahzRrtdencM9/EMA1cxE2lzkLhz3yv8zEFFFAAAYOdPP47yHpt3r59OxJ8yjOZe3p6EqEOgQ5f5AQ6WRVOFvKwmbRj6+/vjyof1kV1D+Wa9fX18SOQvSaPH8m3UkABBRRQQAEFFMihgMePOcR11QoooIACCiigwAoIMJ4OrdcGBwejQ09ZWVlcmN3V1ZVor7vQBdmc52M22FmBneAqFFiDAgY7edzpjKNDkPPnP/85/fGPf0w3btyIsXUIdei5SahDis8XPjNVOzxHSSdXanIFAGWdjMXDlQDM//iP/xgt2bgCwGAnjzvTt1JAAQUUUEABBfIg4PFjHpB9CwUUUEABBRRQYBkCXJTNkAucx2tqaooLsL/97W/HxdhvG0KBc3/Z+TwrdpaxA3ypAmtUwGAnDzueL3jS+97e3qjUIdS5cOFCDKrGF3hjY2OMmcNYOvxNsp8FO/wwEOhwS6DDODyMzTMyMhJB0J49eyL955Zxd5wUUEABBRRQQAEFil/A48fi34d+AgUUUEABBRRYGwJcaM15vC1btsQ5PcbL5lxfa2urLdbWxj8BP6UCqyJgsJMH9qwk8/r16+mLL75IFy9ejJCGEKetrS0dOHAgxszp6OiIEswsrSfpp1qHEIf2bZcvX37Vuo3HCYo+/fTT+AT8aBjs5GFn+hYKKKCAAgoooEAeBDx+zAOyb6GAAgoooIACCqyAABdoNzQ0xDk9Ou88ePAgLvDOxs+2GmcFkF2FAgp8Q8Bg5xskK/8AvdH7+vrSrVu3opUaX/Dl5eUR6nz44YcR6pw6dSq1t7enqqqqSPfZCtqv0aKN5QmAamtro+8mPxi0YaM1ByERA62dPn06luUqAX8wVn4fukYFFFBAAQUUUCCfAh4/5lPb91JAAQUUUEABBd5fgHZrjKXDuT4uzmF87K+//jrO0/EYwy7Md66OC7s518ctz8+3zPtvla9UQIFSFzDYycMeJq1nbJx79+5FWzW+1CnHJMz58Y9/nI4dOxbVNnyR82WfTXyhM4AaYc++ffsSVTlcAUA553/9139FUMTAbIRGtGmbmZmJsk9e46SAAgoooIACCihQvAIePxbvvnPLFVBAAQUUUGBtCWTn77ilww7n6f7t3/4tffbZZzHeDqHPfBdic26QC7V3796dCIcMdtbWvxs/rQLLFTDYWa7gIl7PFZeMi8PMfb7QCWqOHz+ejhw5kjo7OxdcC1/q9OhkJhAi3GEd586diysAGH+Hyh1mxuEh1DHYWZDTJxRQQAEFFFBAgaIQ8PixKHaTG6mAAgoooIACCoRANs4OF2cPDw+n+/fvx/m7qamptG3btnmDHV7DxTy0bKNrj5MCCiiwFAGDnaVoveeypPW0UxsdHY3kfufOneno0aMx84W/2Ilwp66uLqp92v/Stq2npyeuAsjWPzY2FuEPyzkpoIACCiiggAIKFK9Adnzn8WPx7kO3XAEFFFBAAQXWhgAXZRPScDH2nj170ubNm6P6hguvOUdHNQ7TmxU5XMCdVeq8+dzakPNTKqDAcgQMdpajt8jXPn/+PJHQM3OfL+6WlpaYub/YiR8E2rXt2LEjAh7G1hkZGUnPnj17bf2LXZ/LKaCAAgoooIACChSmgMePhblf3CoFFFBAAQUUUOBNgex8XXYh965du6IC511VOE1NTa+qed5cp38roIAC7xIw2HmX0Ao8/+LFiyi/ZAA17vOFT6DDzP2lTm++npJN1p2tf6nrc3kFFFBAAQUUUECBwhLw+LGw9odbo4ACCiiggAIKLCRAVU5tbW2ENM3NzTEGNsdy72qxxsXbdObhPJ8VOwvp+rgCCiwkYLCzkMwKPk455qZNm16VV84NYri/lIm0nx+HmZmZVz8UfPlTupmVby5lfS6rgAIKKKCAAgooUHgCHj8W3j5xixRQQAEFFFBAgfkEOC/HeT8uuGb8a8bBZrxEKrDfVrVDRx7G3+HCb4Od+WR9TAEF3iZgsPM2nRV6ji/36urqmOmTzhf94OBgzDy+ffv2Rb0TPwbM/DgwEBszAQ+9O7P1c99JAQUUUEABBRRQoLgFPH4s7v3n1iuggAIKKKDA2hHIKq1v3ryZfv3rX6eLFy8mxsHm/N/bgp0jR46kn/3sZ+nEiRMxFs/7dPVZO8p+UgUUeFPAYOdNkRz8TdjCeDjM3GesnevXr6fGxsYouSTY4T/e3/YFzg/B9PR0Ihi6c+dO6uvrix8J0n9KPkn5q6qqYj05+AiuUgEFFFBAAQUUUCCPAh4/5hHbt1JAAQUUUEABBZYhwEXXjIF9+/btdP78+XTt2rXoqsN5PqqwF6rG4Zxe1q7tbQHQMjbNlyqgQAkLGOzkYecSvNAzk5n7Dx48SF988UUEOS0tLRHKUHGzULDDlzszoc6ZM2fSH/7wh3T37t0IiNh8SjYNdvKwI30LBRRQQAEFFFAgTwIeP+YJ2rdRQAEFFFBAAQWWKfDo0aO4CJsLsbkom3F2Pv7449TW1hYXeC90vq++vj51dHTEMgRATgoooMBSBAx2lqL1nssyGBpf5u3t7enChQuR4vf29iYeb21tjXZq3BLu8B/xjJXDFzphDuk9rdfo0Xnr1q0Idc6dOxdt2PhhoOpn9+7dr1670FUA77npvkwBBRRQQAEFFFBgFQQ8flwFdN9SAQUUUEABBRR4D4Fnz55FV53Jyck4n0dgc/LkyfTBBx+8NdihQpsuPo6Z/R7ovkQBBZLBTh7+EVRUVKT9+/dHpc6XX36Z+vv7U5bm/8d//EeUafI84Q9VPVlrNnp0EugMDQ29Sv4p6+RvfiwaGhrSt771rfThhx+m2traKO002MnDDvUtFFBAAQUUUECBHAt4/JhjYFevgAIKKKCAAgqsoADn4whq6KjD+bqmpqa4GPttrdh4zlBnBXeCq1JgjQkY7ORhh5eVlcWX+d69e9PRo0ejhRoDqtGSjb6bBDXDw8OJtmzzBTs8Rznn4OBgGh8fj0oe/mO/s7Mzgh0GW2N8HUOdPOxM30IBBRRQQAEFFMiDgMePeUD2LRRQQAEFFFBAgRUQYNxszstVVlbGMAtU8NCS7cmTJ68686zA27gKBRRQ4DUBg53XOHLzB4ELX/L02PzBD36Q+A91qnEYXI3KnampqUTQ09fX9+oLn9dkrdiy5fhB4MeBlm0HDhyISh2qdaj2IehxUkABBRRQQAEFFCgNAY8fS2M/+ikUUEABBRRQoPQFsha6XLj9pz/9KS7KvnTpUoQ8DKGwbdu2eS/Gzlqxva2qp/T1/IQKKPC+AgY77yu3hNfxH+bMlGMePHgwAhuSe5L8gYGB6MNJaEPbtbGxsQh9Zmdn4zWUZBIKMVPKyRUAtGyjSufUqVNRtUOVj5MCCiiggAIKKKBA6Qh4/Fg6+9JPooACCiiggAKlLcA5O87xEeBwcTZDMHzxxRfRqedtwQ5j8Rw6dCjO9zGONgGPkwIKKLBYAYOdxUqtwHIk8YyFQyhDGEO1zYULF9KtW7fiS//+/ftpYmIiyjWfPn0ayT6VOIQ5WaDDF/6+ffvSnj17ol8n63NSQAEFFFBAAQUUKE0Bjx9Lc7/6qRRQQAEFFFCgdATouMNMd57nz5/HkAuc3ztz5kx07eGi7fmmY8eOpZ///OdxIfiWLVsMduZD8jEFFFhQYP5vlgUX94n3EaASh3JMvtT5gucLPRsQlzR/165dEeyMjIykycnJCHZI+LPlSP2p9mG5w4cPR8UOgQ6lnk4KKKCAAgoooIACpSfg8WPp7VM/kQIKKKCAAgqUpgDDJjAmNuf0mMrLy6OCJwtrFqrEodIna8NGtbaTAgoosBQBg52laL3nsoQ6v/rVrxL9NfmSJ6Qhle/s7Ezt7e0xXs7jx4+jXJMfAxL++VqxEeQQ8nDLj4OTAgoooIACCiigQGkKePxYmvvVT6WAAgoooIACpSfAcAs9PT1x0TZBDcMw/O3f/m2c96P6mjZr802MoU1HniwAmm8ZH1NAAQUWEjDYWUhmBR/nC767uzvarvX19SW+uKnGob0abdVaW1tX8N1clQIKKKCAAgoooECxC3j8WOx70O1XQAEFFFBAgbUiQHceqq3pvkO1DuPqMPzC0aNH09uCHUIgx9ZZK/9K/JwKrLyAwc7Km35jjVlLNb7cGTtnbGwsWrONjo7Gl/43XuADCiiggAIKKKCAAmtawOPHNb37/fAKKKCAAgooUEQCBDQEOAy3wEXcdOqh4w5/Z63WFvo4tmBbSMbHFVDgXQIGO+8SWoHn+XKvqamJL3a+sKemphKVO8wk+iT7JPR+ma8AtqtQQAEFFFBAAQVKQMDjxxLYiX4EBRRQQAEFFFgTAhy3ZWEO5/aovOZibsbSps0aF+zMN3EuMHvec4LzCfmYAgq8TWD+b5a3vcLnlixQVlaWdu7cGTP3Hzx4EK3Z7ty5E1/0T548STy+0Bf9kt/QFyiggAIKKKCAAgoUtYDHj0W9+9x4BRRQQAEFFFhDAhy3NTc3xwXcExMTaWBgINqxEfDU19fHWNnzcVDRw/Pbt2+Ppw135lPyMQUUWEjAYGchmRV8fOvWrWnXrl0xns6VK1ciuadS5969e+nixYupoqIifgBI97OkfgXf3lUpoIACCiiggAIKFJmAx49FtsPcXAUUUEABBRRYswIEMswvXryILj39/f3p3LlzcWH324KdpqamdOLEiRiXx04+a/afjx9cgfcWMNh5b7rFv5AEvqOjI1GZMzw8HC+8fPlyBDu/+c1vYsyd06dPp66urkjqrdxZvK1LKqCAAgoooIACpSjg8WMp7lU/kwIKKKCAAgqUokB2vm9wcDCCHVqwzczMpOvXr7/1Au4jR46khoaGmBmLx0kBBRRYioDBzlK0lrHsy5cvYyA1xtphJryhJRsVO/wAPH36NPEDQMs2BljjedL6t32xZyWaXNGZlW6+a1C2ZXwEX6qAAgoooIACCiiQRwGPH/OI7VspoIACCiiggALvKcC5OMbZqaurSx988EGMt7OYVdGCzYu7FyPlMgooMJ+Awc58Kiv8GG3Xbt++nW7cuJHu378fqT2hzezsbIyx8/jx4+jDWV1d/WqwNa7SpEcnPwwsu9BEuLN79+70ySefRFUQrdzetvxC6/FxBRRQQAEFFFBAgcIR8PixcPaFW6KAAgoooIACCrxNgHN4e/bsiQu5CXY4z7eYiQu7W1tbo6rnbRd2L2ZdLqOAAmtPwGAnD/ucwdK6u7sj2Ll7924aGhqKKh16b1KtMzU1FY9t2rQp+mpSgbOUYIfSzYMHD8aPAesw2MnDTvUtFFBAAQUUUECBHAp4/JhDXFetgAIKKKCAAgqsoEBWscO5PC7i5rzeYiaW44LurCPPYl7jMgoooEAmYLCTSeTwlvCGNmtU7NB6ra+vL/Ef68+ePYsv/OytCXpI9WnLxlWa/DAwv+0Lnueo9JmYmIjXlZeXZ6vzVgEFFFBAAQUUUKBIBTx+LNId52YroIACCiigwJoTYDwdxtTmou6rV69Gd57FIFCtw5jbdOKhJdvbzv8tZn0uo4ACa0vAYCcP+5twJqvGoX9mNs7OSr11VVWVCf9KYboeBRRQQAEFFFCgAAQ8fiyAneAmKKCAAgoooIACixDILtRmLO3e3t40MDDw2qsYN5FKHi7k5kJv7nOekECI1m38zTJOCiigwFIEDHaWovWeyxLmdHZ2xpd0c3NztF57z1XN+zKSfdbL+DqcBHBSQAEFFFBAAQUUKG4Bjx+Le/+59QoooIACCiiwdgSotOF8HG3VaK9WUVHx2ocn+KFrD1166OhDoEP3Hf4m1OH1Vuu8RuYfCiiwCAGDnUUgLXcRvtTb2triy50QhtYaKzlRAdTQ0BDBjuPrrKSs61JAAQUUUEABBVZHwOPH1XH3XRVQQAEFFFBAgaUKcC6O8XXq6+tTR0dHdOqZuw7CG4Kd0dHRqNShbRuVO5OTk+n58+eGOnOxvK+AAosWMNhZNNX7L1hWVpaamprii50vcpL6lZy4IoCrOinjNOFfSVnXpYACCiiggAIKrI6Ax4+r4+67KqCAAgoooIACSxWgg05tbW2EO5z/49zf3Clrxfbo0aN0//79dP78+fTLX/4ygh7as3kub66W9xVQYLECBjuLlVrGcgyARvDC7KSAAgoooIACCiigwLsEPH58l5DPK6CAAgoooIAChSFAxQ7V1sx01VloIsQh3KGTz29+85v08OHDqNyhNRsX9Ti8wkJyPq6AAvMJOCDLfCo+poACCiiggAIKKKCAAgoooIACCiiggAIKrJAAAVB5eXnMhDhU9kxNTUVLtjerfFboLV2NAgqUsIAVOyW8c/1oCiiggAIKKKCAAgoooIACCiiggAIKKJA7AYZcIJih8oaxcxg3Z76JZR4/fpx6enpiOYIext+hVZuTAgoosFQBg52lirm8AgoooIACCiiggAIKKKCAAgoooIACCijwFwECm4mJiTQ8PByhzeTk5LwutF4bHBxM165di9tdu3bFuDwM3UAbXicFFFBgKQJ+ayxFy2UVUEABBRRQQAEFFFBAAQUUUEABBRRQQIG/ClChQ0s1Qpvr169HwDMfDtU8hD/j4+OpsbExdXZ2ptra2hhfh+odJwUUUGApAgY7S9FyWQUUUEABBRRQQAEFFFBAAQUUUEABBRRQ4K8CtGIjtBkdHY2Knf7+/nltaLnG3Nramtra2tLBgwdTS0tL2rRpU1q3bt28r/FBBRRQYCEBg52FZHxcAQUUUEABBRRQQAEFFFBAAQUUUEABBRR4i8D69euj6qaqqio1NTWlhapveHzLli1RrdPV1ZV2796dampqEq93UkABBZYqYLCzVDGXV0ABBRRQQAEFFFBAAQUUUEABBRRQQAEF/iJQXl4egU5lZWXq6OhIMzMz87pQlZOFQBUVFWnr1q0RCM27sA8qoIAC7xAw2HkHkE8roIACCiiggAIKKKCAAgoooIACCiiggAII0Hbt/v37Ma7O06dPE63YljI9fvw4jY2Npe3bt0cgRMhD6GM7tqUouqwCChjs+G9AAQUUUEABBRRQQAEFFFBAAQUUUEABBRRYhAChzu9+97t07dq1CGgIat5n2rdvX/rhD3+Y9u/f7zg77wPoaxRY4wIGOyvwD4B0/tGjR5HQb968Ob6MuaW80rR9BYBdhQIKKKCAAgooUGICHj+W2A714yiggAIKKKDAmhF49uxZVOuMjo5G5Q4VPO8z1dbWRtu2ly9fJmYnBRRQYCkCBjtL0VpgWUKdO3fuJBL66urqtGPHjpjLysriFYY7C8D5sAIKKKCAAgoosEYFPH5cozvej62AAgoooIACRS9ACzXG0tm4cWOanJxccEydd33Q1tbWOI/oheHvkvJ5BRSYT8BgZz6VJT42Pj6evvrqqzQ4OBiBDuEOM1/0hDtbtmx5NVPJk/29adOm+BHgC9xJAQUUUEABBRRQYO0IePy4dva1n1QBBRRQQAEFSktg69atqa2tLTE2zpMnT9Lz589f+4D8zeMzMzMxz87ORkcfzgNm5wm5X1NTk6qqqtKGDRvs+POaoH8ooMBiBAx2FqP0jmXorfnpp5+ms2fPpiy44Uu+srIy1dXVJUor6+vr4z5/Z/ep7Nm2bVu85h1v4dMKKKCAAgoooIACJSTg8WMJ7Uw/igIKKKCAAgqsKYHy8vLU0tIS5/devHjxjTZqDx8+TAMDA2lkZCRxn4CH8IYLvTlHyLlBzhlyQTjnBa3YWVP/fPywCqyYgMHOClDSS7Onpyddvnw5vsxpvUY5Jl/Q2Rc2X9rZnAU7JPN8kRMCZVU83GbhUHafFN8v+RXYUa5CAQUUUEABBRQoEAGPHwtkR7gZCiiggAIKKKDAEgU450e1zpsTrXYJcwh1bt++HZ19pqamEmMrcl6P84T8zXJ79uyJUIdziA7h8KakfyugwGIEDHYWo/SOZfgCJnxhZgA1Bjyj7JJUni/vBw8epHv37r0W2BDakPDzQ0DlztxKniwAym5ZhuVJ950UUEABBRRQQAEFil/A48fi34d+AgUUUEABBRRQIBPgXODw8HD67W9/Gx19bty4EePvcDE35/Oo7GHmfOGuXbvS9773vXTy5Mm0b9++uCg8W4+3CiigwGIFDHYWK/WW5Qhmjh07Fl/QXH1JH00CHUots1seY0A1/uZLnC98vtgJd6jayap4sjBn7t/026Q0k2UJeLJKnjfvsz5T/rfsKJ9SQAEFFFBAAQUKRMDjxwLZEW6GAgoooIACCiiwTAEu8s6qsc+dOxcdfXiMCh3O73E+j785L8j43P39/YnlOI/H83T08XzeMneCL1dgDQoY7KzATmfAtJ/97GfpBz/4QWIgXCp0RkdHY6Z/enafW56j5JJwh6T+8ePHcZ/HKNWc24YtC24IdfiPf77o36zs4Qcga/fGVQBM/hiswE51FQoooIACCiigQA4FPH7MIa6rVkABBRRQQAEF8ijAub3e3t508+bNdOfOnQhsOEd46NChOI9HsMMF3rRpu3btWszXr1+P84JcKN7e3u4QDHncX76VAqUiYLCzAnuS0IWqmq6urjQxMZHGxsbmDXWygId+mnzpU8Uzt6qHah4CHsIf7mcDsBHw0I6turr6tcqerKqno6MjKoaam5ujHRyJv5MCCiiggAIKKKBA4Qp4/Fi4+8YtU0ABBRRQQAEFliLA+b2hoaEIbriQmwuzjx8/nj766KM4X8h5PSbO9zU0NMT98+fPRxjEBeK8nmUYu8dJAQUUWKyA3xiLlXrHclTJUG3Df6RTOUPokoU2WTs2/mYmvCH8ySp73qzqmVvZQ7iTlWvyRc9rSP+zah5u+bGgqodwiQDIYOcdO8unFVBAAQUUUECBAhDw+LEAdoKboIACCiiggAIKLFOA836c5+O83c6dO1NTU1PMnKdjPO5sojVbZ2dntGPj4u3Z2dkYn5sWbfxtsJNJeauAAosRMNhZjNIilyFQYS4rK5v3FZRdMvNFn1X2vBnqZH8T4PDFTgjELWHPw4cPo2cnYc/ciZJOnueHhB8FJwUUUEABBRRQQIHiEPD4sTj2k1upgAIKKKCAAgosJMC5vqzrDuEMF2FzbpALwOcOl8BxHxeDM69fvz6GZuA8Xna+cKH1+7gCCigwn4DBznwqOXos+zLnC54kniobKnsIZLKqnuyWyh7Cn+Hh4ei9+fnnn6cbN25ExQ5t3JwUUEABBRRQQAEFSl/A48fS38d+QgUUUEABBRQobgHCHM7xccuF2gQ609PTcfE1AU52PEdHnmxsbi7eJujhYm2CHqt1ivvfgFuvwGoIGOzkWZ0v84WuzCSl50ue4IZQh3JNxuNh+exHYO7m8jw/AJWVlXElAD8C8y039zXeV0ABBRRQQAEFFCguAY8fi2t/ubUKKKCAAgoosLYEuIC7rq4uhmfgvN7AwEC6ePFinKMj8OH8HVU5dOTp6+tLV69eDSAu+qY9G9U9BEBOCiigwFIEDHaWopXjZfnyJ8jp7e1NV65cSZcvX44fAsbUYRA2wh4qepj4D3xCnZaWltTW1hY/HlwR4A9BjneSq1dAAQUUUEABBQpIwOPHAtoZbooCCiiggAIKrEkBKm44Nzc4OBjVOnfv3k2/+MUv0tmzZ9OuXbsivHn+/HkaGRmJrjyMx0Pgs2/fvujoQ/Dj+bw1+U/HD63AsgQMdpbFt7wX8x/ijLeTjaNDuSYBDj8ABDvXrl1LN2/eTIy7Q69OKnJqampSRUVFVOk0Njam9vb2dOzYsdTQ0BA9PP0hWN4+8dUKKKCAAgoooEAhC3j8WMh7x21TQAEFFFBAgbUowIXWnK8jxDl06FCMnUOrtVu3bsUF3FyYTZceKnYYcoG/We748eOptrY2OvWsRTc/swIKLE/AYGd5fu/9akowabnW39+fqMghyGEMHUIdwh2+7Jn5ISDUoR0bX/adnZ1p//796cCBA2nPnj2JcIdQh7F6TPjfe3f4QgUUUEABBRRQoOAFPH4s+F3kBiqggAIKKKDAGhSgqw7n5Kja+clPfhLn7ejCQ0s2zv0xcyE2LddOnDiRdu/eHaFOR0dHnOtbg2R+ZAUUWAEBg50VQHzXKviPcOaZmZmozqHdGqENAc69e/eiKodghySfXpuEOVTnkOBnPTrpu0nbNco0CXYOHjyYWltbo3KHXp5OCiiggAIKKKCAAqUj4PFj6exLP4kCCiiggAIKlK4Ax2y0WaMjD+fyurq6or0aY+dkF29PT0/HBduc26PzDoEO5/e4gNuxskv334afTIFcCxjs5Fr4L+vPvuTpoUl4c/369ajQoVKH/pujo6NRmkmgQ4rPDwHt1ghyCHAIcvhhIMjhR6CqqioCHYIfrghwUkABBRRQQAEFFCgtAY8fS2t/+mkUUEABBRRQoPQEOF6jxRrBDef3mOiss3PnzsS4O3v37o1zfjzPRNjD87Rt4z6hjsFO0Pg/CijwHgIGO++B9q6X8KVOWk9IQ3XOxMREItShGod2a4ydQ4VOb29vPMeyhDQMnMaXP1/wtFcjxc+CHX4MsnZrtGVzUkABBRRQQAEFFCgdAY8fS2df+kkUUEABBRRQoLQFCHQYNoFzfrRb43xfd3d3XIR9+vTpuDCb4KaysjLarzGuDl176OTDxdxZmMN5QC7Y9jxfaf978dMpkCsBg50cyBLUUH3D+DkEOAQ5zAQ5Dx48iDCHVmwEPwyAS4rf3NwcY+YweBohDqEOIQ8/AlTv8IPgGDo52FmuUgEFFFBAAQUUKAABjx8LYCe4CQoooIACCiigwCIECHUIaejE85vf/CZ99dVXcQ6Qjju0WaPjDhPn/MbHx9OlS5fS//7v/8b97CLukydPxrI7duww2FmEuYsooMA3BQx2vmmy5Ef4D3F6aT569CjGziG8GRkZiV6aV69ejVCHSh0e40uddJ5UvqmpKUIbyjAZOI1Ahwqdzs7OV+PnZCn+kjfKFyiggAIKKKCAAgoUrIDHjwW7a9wwBRRQQAEFFFDgrQJcqJ1dzP3ll1/GkAvr169/VYmTvZjHGBe7rKwsbd68OcIgxt3h3CDT06dPExd487yTAgoosFQBg52lis2zPKEOvTRJ6qnQYQydbPwcKnMozWTmi5svdcbJIbxhoDSCnD179kR1DoOmUaFDdQ6t2Qx15sH2IQUUUEABBRRQoAQEPH4sgZ3oR1BAAQUUUECBNSlAFc65c+fS2bNnE23WOJ/34Ycfpo8++ijO72UodOjZtWtXdOppa2uLC795HW3ZPv300xh/h2EXmD0HmKl5q4ACixUw2Fms1FuW4wudsku+nAl2bt68mXp6eqJ6hyCH5J0wh/JKbmm7RqhDiSbBDiWaPGdC/xZkn1JAAQUUUEABBUpIwOPHEtqZfhQFFFBAAQUUWFMCXLzNkAtU31CRQxceQp1jx47F+b0MgyEVqqqq4gLubExt2rgRCF28eDEu/r5//35U8jjWTqbmrQIKLFbAYGexUm9ZjmqdX/3qV+mzzz6LMIfxdaanp+MLmlJLvryPHj0a5ZWEOQQ5WdBDhQ7VOXyBOymggAIKKKCAAgqsDQGPH9fGfvZTKqCAAgoooEDpCXDOj3G0CXg4z0egwwXcDLVA0PPmlLVka2lpSZ988kmcA6TbD0M5MLMezg9u2LDhzZf6twIKKLCggMHOgjSLf4IghyodqnXmTtkXMrd8sTOuTla1Q7s1Qp+XL18meqzzJU/ZZTbPXY/3FVBAAQUUUEABBUpLwOPH0tqffhoFFFBAAQUUWDsCDLVA9TVj5DB+NsMtNDQ0xHm/+RQ418e5Qap3aM/W19cX5wmz8boJijhn6KSAAgosRcBgZylaS1x2dnY2yikpqyT04YuaqzNpxcYXPj006+rqohcn/Tj5Et+4caN9NZfo7OIKKKCAAgoooECpCHj8WCp70s+hgAIKKKCAAqUqwPEaoQ4TlTZcxL2YTjwEPCzHhd5cAE5AxHpmZmYSLdqcFFBAgaUIGOwsRWuBZfkyJpih5JIvY2a+nPlSZuaKTNJ4gh0GVSPMyQKd7H5NTU38GJDcM9ZO9iWf3fIe3Gcm5efHwEkBBRRQQAEFFFCgOAU8fizO/eZWK6CAAgoooIACWWs1QhpCHjrx0JHnXVMWCBHmZEEOF3h7nu9dcj6vgALzCRjszKeyxMcqKiqip+bExEQaGRlJo6OjaWxsLD1+/DjWRMgzOTmZKLHkuXv37n0juCHMoT0bKT8h0ZvBT/Y3Y/MQ/mSt25a4qS6ugAIKKKCAAgooUAACHj8WwE5wExRQQAEFFFBAgfcQ4KJrLtDmPB9j5AwMDMR42u9aFYEO5wvp7MN5Qs7tcS6QFm2Lqfh51/p9XgEF1paAwc4K7G/CmOPHj6fy8vL4cia8yQY/40s+q+LhNiux5AucwIeZVJ8KHMIdvsz5ccgqebJAJ7vlOU4EsGxW2cOPAIEP72/gswI71FUooIACCiiggAI5FvD4McfArl4BBRRQQAEFFMiRABdct7a2RmceOvRwfo7hFgh8OEdHZfbcTjtU9HB+cGhoKMbovn79elTscDxIK7dsaIYcba6rVUCBEhUw2FmBHUuFzenTp9MHH3wQIQ5f1lTrEN4Q8jBTyUMin838zUBrU1NT8Ro2g+CH5P7Ro0fRsi1rv5bdZmEOwQ4BT1bZwyBtJ0+eTLt27YqEnxJOJwUUUEABBRRQQIHCFfD4sXD3jVumgAIKKKCAAgq8TYDzcgcOHEh07vniiy9i+AXO2dFqbd++fXGx9twLrzlPSFXPxYsX029/+9sId1i+vb09OvcQCLG8kwIKKLAUAYOdpWgtsCyVMiT12cQXOb0yCWio3MnCnOw2C3l4jh8BlpuvqicLfUj2s96bfNFzZQAVOlmwwzp4/4aGhujLabCT7QlvFVBAAQUUUECBwhTw+LEw94tbpYACCiiggAIKvEuAqpy9e/fGOb9r167FBd0XLlyIqpzBwcEIdghrqNrhHCHn7fr7+xOVOleuXIluPgRAR44ciQu3PY/3LnGfV0CB+QQMduZTWeZjfHHzpUwpJT0yKa2kmiZrw5aFOFT1EOpQuUPokwU+bwZAVP7wGgIefhB4HUEPj/PDQEXPd77znVg/ib+TAgoooIACCiigQHEJePxYXPvLrVVAAQUUUECBtSvA+T6qbbIxtc+fP59u3bqVCHd4jjkbH5tqnenp6TiHx7k8ztt1dXWlv/u7v4thHRh6wUkBBRR4HwGDnfdRe8dr+A9zZqprCHb4Qp9vIqghsKEyZ6FQh5CH4Ofhw4cR6LD8fAERPyb8QDBej5MCCiiggAIKKKBAcQl4/Fhc+8utVUABBRRQQIG1K5BdxE24wwXb/M2xXHd3d5y7I8jhMSbO13GRNs/TfWfPnj0R6Bw7dizuc7G2kwIKKPA+AgY776O2Qq+hqocvcG5px9HY2PiN0IYQhx8JyjbfbOuWhUG8jisBWA8/FE4KKKCAAgoooIACpSng8WNp7lc/lQIKKKCAAgoUn0BlZWU6fPhw2rlzZyKoGRr6P+3dQUrjABQG4M7QbUEENxaqR/DKHsGbeIRuddUbzMwLBKYuHrFq+6f5AkXkpfb1e5KG/E3yNjzqC9rj1XYq4KljdnU1n7u7u9V2ux3WrzN16pige+vMb+46JpAiINi54CQqhFmv18Oju4RahTt1Vs94ybaPl22rD4a6v07Kzdaqz9fX1wvKemkCBAhcVqC2gbUttBAgQOC7Ba51/3Gqk/3MqVLWI0DgVAH7cafKeR6B5QlUMFPH5OpMnLoFQ30p+/39ffhidl15p66sU+vUPXlub2+HR61bX+62ECBA4KsCgp2vCp7h+RX+bDab4cOgPgB2u91wCbfxsmzjB8l41s4ZWmpfYr/fr56fn1cvLy/teooECBC4VoE68FjbQgsBAgQuJTC3/cepTvYzp0pZjwCBUwXsx50q53kEliswnlFdx+zq2Nz9/f1wn+y6XUKdkVP7ZfVl7PGxXCnvnACB7xQQ7Hyn5g/9rfoQmNPG3zcpf+gfwZ8lQIAAAQIECEwUmNv+48S3NZwN6czwqVrWI0CAAAECBM4h8P8Z1c7GOYe41yBAoAR+YyBAgAABAgQIECBAgAABAgQIECBAgAABAgQIEJiHgGBnHnPSJQECBAgQIECAAAECBAgQIECAAAECBAgQIEDAGTv+BwgQIECAAAECBAgQIECAAAECBAgQIECAAAECcxFwxs5cJqVPAgQIECBAgAABAgQIECBAgAABAgQIECBAYPECgp3F/wsAIECAAAECBAgQIECAAAECBAgQIECAAAECBOYisJ5Lo/rMEbi5uVk9PT3lNKQTAgQIzEygtqG1LbUQIECAwLGA/cxjD78RIJAnYD8ubyY6IkCAAAECSxT49effssQ37j2fLnA4HFb7/X5VPy0ECBAg8HmBOnD5+Pgo3Pk8nWcQIHDlAvYzr3zA3h6BKxCwH3cFQ/QWCBAgQIDADAUeHh6OuhbsHHH4hQABAgQIECBAgAABAgQIECBAgAABAgQIECCQI/Ax2HGPnZzZ6IQAAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0AoIdloeRQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAjoBgJ2cWOiFAgAABAgQIECBAgAABAgQIECBAgAABAgQItAKCnZZHkQABAgQIECBAgAABAgQIECBAgAABAgQIECCQIyDYyZmFTggQIECAAAECBAgQIECAAAECBAgQIECAAAECrYBgp+VRJECAAAECBAgQIECAAAECBAgQIECAAAECBAjkCAh2cmahEwIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAKyDYaXkUCRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQI5AoKdnFnohAABAgQIECBAgAABAgQIECBAgAABAgQIECDQCgh2Wh5FAgQIECBAgAABAgQIECBAgAABAgQIECBAgECOgGAnZxY6IUCAAAECBAgQIECAAAECBAgQIECAAAECBAi0AoKdlkeRAAECBAgQIECAAAECBAgQIECAAAECBAgQIJAjINjJmYVOCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQKtgGCn5VEkQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECOQICHZyZqETAgQIECBAgAABAgQIECBAgAABAgQIECBAgEArINhpeRQJECBAgAABAgQIECBAgAABAgQIECBAgAABAjkCgp2cWeiEAAECBAgQIECAAAECBAgQIECAAAECBAgQINAKCHZaHkUCBAgQIECAAAECBAgQIECAAAECBAgQIECAQI6AYCdnFjohQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECLQCgp2WR5EAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgkCMg2MmZhU4IECBAgAABAgQIECBAgAABAgQIECBAgAABAq2AYKflUSRAgAABAgQIECBAgAABAgQIECBAgAABAgQI5AgIdnJmoRMCBAgQIECAAAECBAgQIECAAAECBAgQIECAQCsg2Gl5FAkQIECAAAECBAgQIECAAAECBAgQIECAAAECOQKCnZxZ6IQAAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0AoIdloeRQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAjoBgJ2cWOiFAgAABAgQIECBAgAABAgQIECBAgAABAgQItAKCnZZHkQABAgQIECBAgAABAgQIECBAgAABAgQIECCQIyDYyZmFTggQIECAAAECBAgQIECAAAECBAgQIECAAAECrYBgp+VRJECAAAECBAgQIECAAAECBAgQIECAAAECBAjkCAh2cmahEwIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAKyDYaXkUCRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQI5AoKdnFnohAABAgQIECBAgAABAgQIECBAgAABAgQIECDQCgh2Wh5FAgQIECBAgAABAgQIECBAgAABAgQIECBAgECOgGAnZxY6IUCAAAECBAgQIECAAAECBAgQIECAAAECBAi0AoKdlkeRAAECBAgQIECAAAECBAgQIECAAAECBAgQIJAjINjJmYVOCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQKtgGCnj+zq2AAAAW1JREFU5VEkQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECOQICHZyZqETAgQIECBAgAABAgQIECBAgAABAgQIECBAgEArINhpeRQJECBAgAABAgQIECBAgAABAgQIECBAgAABAjkCgp2cWeiEAAECBAgQIECAAAECBAgQIECAAAECBAgQINAKCHZaHkUCBAgQIECAAAECBAgQIECAAAECBAgQIECAQI6AYCdnFjohQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECLQCgp2WR5EAAQIECBAgQIAAAQIECBAgQIAAAQIECBAgkCMg2MmZhU4IECBAgAABAgQIECBAgAABAgQIECBAgAABAq2AYKflUSRAgAABAgQIECBAgAABAgQIECBAgAABAgQI5AgIdnJmoRMCBAgQIECAAAECBAgQIECAAAECBAgQIECAQCsg2Gl5FAkQIECAAAECBAgQIECAAAECBAgQIECAAAECOQJ/AdGGO8BwamkxAAAAAElFTkSuQmCC.png" class="img-fluid figure-img"></p>
<p></p><figcaption class="figure-caption">image.png</figcaption><p></p>
</figure>
</div>
<p>The last important operation we’ll need a <code>vjp</code> method for in order to use our vectorized <code>AutogradValue</code> class for a neural network is matrix multiplication. Let’s consider the operation:</p>
<p><span class="math display">\[\mathbf{C} = \mathbf{A}\mathbf{B}\]</span></p>
<p>Where <span class="math inline">\(\mathbf{A}\)</span> is an <span class="math inline">\(N\times h\)</span> matrix, <span class="math inline">\(\mathbf{B}\)</span> is a <span class="math inline">\(h \times d\)</span> matrix and <span class="math inline">\(\mathbf{C}\)</span> is an <span class="math inline">\(N\times d\)</span> matrix.</p>
<p>Recall that for <code>vjp</code> want to compute <span class="math inline">\(\frac{dL}{d\mathbf{A}}\)</span> (and <span class="math inline">\(\frac{dL}{d\mathbf{B}}\)</span> ) given <span class="math inline">\(\frac{dL}{d\mathbf{C}}\)</span>. We can compute a given entry <span class="math inline">\(i,j\)</span> of <span class="math inline">\(\frac{dL}{d\mathbf{A}}\)</span> by applying the chain rule using each element of <span class="math inline">\(\mathbf{C}\)</span>:</p>
<p><span class="math display">\[\frac{dL}{dA_{ij}} = \sum_{k=1}^N \sum_{l=1}^d \frac{dL}{dC_{kl}}\frac{dC_{kl}}{dA_{ij}}\]</span></p>
<p>However, each entry of <span class="math inline">\(\mathbf{C}\)</span> only depends on a single row of <span class="math inline">\(\mathbf{A}\)</span> and a single column of <span class="math inline">\(\mathbf{B}\)</span>, thus for most <span class="math inline">\(i,j,k,l\)</span>, <span class="math inline">\(\frac{dC_{kl}}{dA_{ij}}=0\)</span>.</p>
<section id="q8" class="level4">
<h4 class="anchored" data-anchor-id="q8">Q8</h4>
<p>Using this observation, simplify the expression for <span class="math inline">\(\frac{dL}{dA_{ij}}\)</span> above. (The derivative of the loss with respect to the entry of <span class="math inline">\(\mathbf{A}\)</span> at row <span class="math inline">\(i\)</span>, column <span class="math inline">\(j\)</span>).</p>
<p><em><strong>Hint:</strong> Your answer should have a similar form, but should only have a single summation and a subset of the indices <span class="math inline">\(i,j,k,l\)</span>.</em></p>
<p><span class="math display">\[\frac{dL}{dA_{ij}} = \]</span></p>
</section>
<section id="q9" class="level4">
<h4 class="anchored" data-anchor-id="q9">Q9</h4>
<p>Recalling the definition of matrix-multiplication, give a simple expression for <span class="math inline">\(\frac{dC_{il}}{dA_{ij}}\)</span>, then substitue it into your expression for <span class="math inline">\(\frac{dL}{dA_{ij}}\)</span>.</p>
<p><span class="math display">\[\frac{dC_{il}}{dA_{ij}}= , \quad\frac{dL}{dA_{ij}} = \]</span></p>
</section>
<section id="q10" class="level4">
<h4 class="anchored" data-anchor-id="q10">Q10</h4>
<p>Using your expression in Q13, write an expression for <span class="math inline">\(\frac{dL}{d\mathbf{A}}\)</span> as a matrix multiplication between two of the 3 given matrices: <span class="math inline">\(\frac{dL}{d\mathbf{C}}\)</span>, <span class="math inline">\(\mathbf{A}\)</span>, <span class="math inline">\(\mathbf{B}\)</span>. Make sure to inlude any nessecary transposes.</p>
<p><em><strong>Hint:</strong> Recall that <span class="math inline">\(\frac{dL}{d\mathbf{C}}\)</span> is the same shape as <span class="math inline">\(\mathbf{C}\)</span> (<span class="math inline">\(N\times d\)</span>), <span class="math inline">\(\mathbf{A}\)</span> has shape <span class="math inline">\(N \times h\)</span> and <span class="math inline">\(\mathbf{B}\)</span> has shape <span class="math inline">\(h \times d\)</span>.</em></p>
<p><span class="math display">\[\frac{dL}{d\mathbf{A}}= \]</span></p>
</section>
<section id="q11" class="level4">
<h4 class="anchored" data-anchor-id="q11">Q11</h4>
<p>Write the corresponding formula for <span class="math inline">\(\frac{dL}{d\mathbf{B}}\)</span>.</p>
<p><em><strong>Hint:</strong> You can use the fact that <span class="math inline">\(C^T = B^T A^T\)</span> and that <span class="math inline">\(\frac{dL}{d\mathbf{C}^T} = (\frac{dL}{d\mathbf{C}})^T\)</span></em></p>
<p><span class="math display">\[\frac{dL}{d\mathbf{B}}=\]</span></p>
</section>
<section id="q12" class="level4">
<h4 class="anchored" data-anchor-id="q12">Q12</h4>
<p>Using the expressions you derived in Q14 and Q15, implement the <code>vjp</code> function for the <code>matmul</code> operation to compute <span class="math inline">\(\frac{dL}{d\mathbf{A}}\)</span> and <span class="math inline">\(\frac{dL}{d\mathbf{B}}\)</span> given <span class="math inline">\(\frac{dL}{d\mathbf{C}}\)</span>, <span class="math inline">\(\mathbf{A}\)</span> and <span class="math inline">\(\mathbf{B}\)</span>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> _matmul(AutogradValue):</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> func(<span class="va">self</span>, a, b):</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> np.matmul(a, b)</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> vjp(<span class="va">self</span>, grad, a, b):</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>        <span class="co"># YOUR CODE HERE</span></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>test_vjp(_matmul, <span class="st">'_matmul'</span>, binary<span class="op">=</span><span class="va">True</span>, true_func<span class="op">=</span>anp.matmul)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Now that we’ve written the <code>vjp</code> versions of our operators, we’ll update our <code>AutogradValue</code> class to use them!</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Note: Remember that above we defined a class for each type of operation</span></span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="co"># so in this code we are overriding the basic operators for AutogradValue</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a><span class="co"># such that they construct a new object of the class corresponding to the</span></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a><span class="co"># given operation and return it. </span></span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a><span class="co"># (You don't need to everything that's happening here to do the HW)</span></span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>AutogradValue.vjp <span class="op">=</span> <span class="kw">lambda</span> <span class="va">self</span>, grad, a: (<span class="fl">1.</span>,)</span>
<span id="cb25-7"><a href="#cb25-7" aria-hidden="true" tabindex="-1"></a>AutogradValue.exp <span class="op">=</span> <span class="kw">lambda</span> a: _exp(a)</span>
<span id="cb25-8"><a href="#cb25-8" aria-hidden="true" tabindex="-1"></a>AutogradValue.log <span class="op">=</span> <span class="kw">lambda</span> a: _log(a)</span>
<span id="cb25-9"><a href="#cb25-9" aria-hidden="true" tabindex="-1"></a>AutogradValue.pad <span class="op">=</span> <span class="kw">lambda</span> a: _pad(a)</span>
<span id="cb25-10"><a href="#cb25-10" aria-hidden="true" tabindex="-1"></a>AutogradValue.<span class="bu">sum</span> <span class="op">=</span> <span class="kw">lambda</span> a: _sum(a)</span>
<span id="cb25-11"><a href="#cb25-11" aria-hidden="true" tabindex="-1"></a>AutogradValue.matmul <span class="op">=</span> <span class="kw">lambda</span> a, b: _matmul(a, b)</span>
<span id="cb25-12"><a href="#cb25-12" aria-hidden="true" tabindex="-1"></a>AutogradValue.rmatmul <span class="op">=</span> <span class="kw">lambda</span> a, b: _matmul(b, a)</span>
<span id="cb25-13"><a href="#cb25-13" aria-hidden="true" tabindex="-1"></a>AutogradValue.<span class="fu">__add__</span> <span class="op">=</span> <span class="kw">lambda</span> a, b: _add(a, b)</span>
<span id="cb25-14"><a href="#cb25-14" aria-hidden="true" tabindex="-1"></a>AutogradValue.<span class="fu">__radd__</span> <span class="op">=</span> <span class="kw">lambda</span> a, b: _add(b, a)</span>
<span id="cb25-15"><a href="#cb25-15" aria-hidden="true" tabindex="-1"></a>AutogradValue.<span class="fu">__sub__</span> <span class="op">=</span> <span class="kw">lambda</span> a, b: _sub(a, b)</span>
<span id="cb25-16"><a href="#cb25-16" aria-hidden="true" tabindex="-1"></a>AutogradValue.<span class="fu">__rsub__</span> <span class="op">=</span> <span class="kw">lambda</span> a, b: _sub(b, a)</span>
<span id="cb25-17"><a href="#cb25-17" aria-hidden="true" tabindex="-1"></a>AutogradValue.<span class="fu">__neg__</span> <span class="op">=</span> <span class="kw">lambda</span> a: _neg(a)</span>
<span id="cb25-18"><a href="#cb25-18" aria-hidden="true" tabindex="-1"></a>AutogradValue.<span class="fu">__mul__</span> <span class="op">=</span> <span class="kw">lambda</span> a, b: _mul(a, b)</span>
<span id="cb25-19"><a href="#cb25-19" aria-hidden="true" tabindex="-1"></a>AutogradValue.<span class="fu">__rmul__</span> <span class="op">=</span> <span class="kw">lambda</span> a, b: _mul(b, a)</span>
<span id="cb25-20"><a href="#cb25-20" aria-hidden="true" tabindex="-1"></a>AutogradValue.<span class="fu">__truediv__</span> <span class="op">=</span> <span class="kw">lambda</span> a, b: _div(a, b)</span>
<span id="cb25-21"><a href="#cb25-21" aria-hidden="true" tabindex="-1"></a>AutogradValue.<span class="fu">__rtruediv__</span> <span class="op">=</span> <span class="kw">lambda</span> a, b: _div(b, a)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>As a final step, we need to update our <code>backward_pass</code> method to use our new <code>vjp</code> method instead of relying on <code>grads</code>.</p>
</section>
<section id="q13" class="level4">
<h4 class="anchored" data-anchor-id="q13">Q13</h4>
<p>Update your <code>backward_pass</code> method to use <code>vjp</code> instead of grads.</p>
<p><em><strong>Hint:</strong> Recall that <code>vjp</code> directly computes <span class="math inline">\(\frac{dL}{d\mathbf{a}}\)</span>, <span class="math inline">\(\frac{dL}{d\mathbf{b}}\)</span>, whereas <code>grads</code> computed <span class="math inline">\(\frac{dc}{da}\)</span>, <span class="math inline">\(\frac{dc}{db}\)</span></em></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> backward_pass(<span class="va">self</span>):</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">## YOUR CODE HERE</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>AutogradValue.backward_pass <span class="op">=</span> backward_pass</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
</section>
<section id="q14" class="level4">
<h4 class="anchored" data-anchor-id="q14">Q14</h4>
<p>Finally update the <code>nll_and_grad</code> function for our <code>NeuralNetwork</code> class to use our shiny new <em>vectorized</em> reverse-mode implementation.</p>
<p><em><strong>Hint:</strong> We should no longer need to use our <code>wrap_array</code> and <code>unwrap_gradient</code> functions, as <code>AutogradValue</code> objects can now contain arrays!</em></p>
<div class="cell">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> nll_and_grad(<span class="va">self</span>, X, y):</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">'''</span></span>
<span id="cb27-3"><a href="#cb27-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Get the negative log-likelihood loss and its gradient</span></span>
<span id="cb27-4"><a href="#cb27-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-5"><a href="#cb27-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb27-6"><a href="#cb27-6" aria-hidden="true" tabindex="-1"></a><span class="co">        X (array): An N x d matrix of observations.</span></span>
<span id="cb27-7"><a href="#cb27-7" aria-hidden="true" tabindex="-1"></a><span class="co">        y (array): A length N vector of labels</span></span>
<span id="cb27-8"><a href="#cb27-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb27-9"><a href="#cb27-9" aria-hidden="true" tabindex="-1"></a><span class="co">        nll (float): The negative log-likelihood</span></span>
<span id="cb27-10"><a href="#cb27-10" aria-hidden="true" tabindex="-1"></a><span class="co">        grads (list of arrays): A list of the gradient of the nll with respect</span></span>
<span id="cb27-11"><a href="#cb27-11" aria-hidden="true" tabindex="-1"></a><span class="co">                                to each value in self.weights.</span></span>
<span id="cb27-12"><a href="#cb27-12" aria-hidden="true" tabindex="-1"></a><span class="co">    '''</span></span>
<span id="cb27-13"><a href="#cb27-13" aria-hidden="true" tabindex="-1"></a>    <span class="co">## YOUR CODE HERE</span></span>
<span id="cb27-14"><a href="#cb27-14" aria-hidden="true" tabindex="-1"></a>    loss <span class="op">=</span></span>
<span id="cb27-15"><a href="#cb27-15" aria-hidden="true" tabindex="-1"></a>    grads <span class="op">=</span></span>
<span id="cb27-16"><a href="#cb27-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> loss.value, grads</span>
<span id="cb27-17"><a href="#cb27-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb27-18"><a href="#cb27-18" aria-hidden="true" tabindex="-1"></a>NeuralNetwork.nll_and_grad <span class="op">=</span> nll_and_grad</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We should be able to run it with a much larger network now!</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>X, y <span class="op">=</span> make_moons(<span class="dv">100</span>, noise<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>model <span class="op">=</span> NeuralNetwork(<span class="dv">2</span>, [<span class="dv">25</span>, <span class="dv">25</span>])</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>gradient_descent(model, X, y, lr<span class="op">=</span><span class="fl">3e-2</span>, steps<span class="op">=</span><span class="dv">250</span>)</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Model accuracy: </span><span class="sc">%.3f</span><span class="st">'</span> <span class="op">%</span> model.accuracy(X, y))</span>
<span id="cb28-6"><a href="#cb28-6" aria-hidden="true" tabindex="-1"></a>plot_boundary(model, X, y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>


</section>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>